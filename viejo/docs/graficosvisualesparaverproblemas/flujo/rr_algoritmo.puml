@startuml RR_Algoritmo_Actualizado
title "Algoritmo Round Robin - Implementación Real del Sistema"

start

:elegirSiguiente() llamado por Motor;
note right
**Contexto de Activación:**
• Motor necesita seleccionar próximo proceso
• Configuración de quantum recibida
• Manejo de expropiación por tiempo
end note

if (colaListos.length === 0?) then (SÍ)
  :return undefined;
  stop
endif

:siguienteProceso = colaListos[0];
:tiempoInicioQuantum = tiempoActual;
:return siguienteProceso;
note right
**Round Robin - FIFO Circular:**
• Primer proceso en cola READY
• Marca inicio de quantum
• Cola mantiene orden FIFO
• NO reordena por ningún criterio
end note

:Motor gestiona despacho y quantum;

' Gestión de Quantum
partition "**Gestión de Quantum**" {
  :Motor programa QUANTUM_EXPIRES;
  note right
  **Eventos de Quantum:**
  • FIN_RAFAGA_CPU vs QUANTUM_EXPIRES
  • Prioridades del motor determinan orden
  • alTickQuantum() verifica expiración
  end note

  :Verificación continua de quantum;
  note right
  **alTickQuantum(tiempoActual, proceso):**
  • transcurrido = tiempoActual - tiempoInicioQuantum
  • return transcurrido < quantum
  • Si false → quantum expirado
  end note
}

' Casos especiales
partition "**Casos Especiales**" {
  :Proceso único con quantum expirado;
  note right
  **Según Consigna TP:**
  • debeExpropiar = true
  • debeReencolar = true
  • consumeTCP = true
  • "lo pasamos a listo y vuelve a asignar CPU"
  end note

  :Llegada de proceso mientras otro ejecuta;
  note right
  **Regla de Consigna:**
  • NO interrumpir quantum actual
  • debeCompletarQuantumSinInterrupcion = true
  • Nuevo proceso espera en cola
  end note
}
stop

note top of start
**ESTRATEGIA ROUND ROBIN - CARACTERÍSTICAS**

**Propiedades de la Clase:**
• nombre = 'Round Robin'
• soportaExpropiación = true
• requiereQuantum = true
• quantum configurable (default: 4 unidades)

**Métodos Clave:**
• elegirSiguiente(): FIFO de cola READY
• alTickQuantum(): verifica expiración
• quantumExpirado(): reinicia quantum
• debeCompletarQuantumSinInterrupción(): true
• manejarExpiraciónQuantumProcesoUnico()

**Estado Interno:**
• tiempoInicioQuantum: para cálculos
• quantum: rodaja de tiempo configurada
end note

note bottom of stop
**ALGORITMO ROUND ROBIN - IMPLEMENTACIÓN REAL**

**Filosofía:** Tiempo compartido equitativo
• FIFO circular con quantum de tiempo
• Expropiación por tiempo, no por llegadas
• Balance overhead vs. tiempo de respuesta

**Reglas Específicas de Consigna TP:**
• Proceso único: consume TCP al re-encolarse
• Primer despacho: siempre consume TCP
• Llegada de proceso NO interrumpe quantum
• Quantum expirado: proceso va al final de cola

**Configuración de Quantum:**
• Quantum grande ≈ FCFS (menor overhead)
• Quantum pequeño ≈ mayor overhead, mejor respuesta
• Valor típico: 20-50ms (4 unidades en simulación)

**Ventajas:**
• Tiempo respuesta predecible
• Fairness temporal entre procesos
• Ideal para sistemas interactivos

**Integración con Motor:**
• Motor programa eventos QUANTUM_EXPIRES
• Verificación continua con alTickQuantum()
• Gestión automática de reencole
end note
  :Agregar proceso al final Ready Queue;
endif

:CPU queda libre;

stop

note right
Round Robin:
- Quantum fijo (ej: 4 unidades)
- TCP SOLO por expiracion quantum
- NO TCP por fin natural rafaga
- Cola circular FIFO
- Garantiza fairness
end note


@enduml
