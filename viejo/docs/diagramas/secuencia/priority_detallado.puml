@startuml
title Priority Scheduling Mejorado - Con Estados Suspendidos
participant "AdaptadorSimuladorDominio" as Adaptador
participant "MotorSimulacion" as Motor
participant "EstrategiaSchedulerPrioridad" as Priority
participant "EstadoSistema" as Estado
participant "EventQueue" as EQ
participant "ReadyQ" as RQ
participant "BlockedQ" as BQ
participant "Logger" as Logger
participant "CPU" as CPU
participant "P1" as P1
participant "P2" as P2
participant "P3" as P3  
participant "P4" as P4
participant "P5" as P5

== Configuración Inicial Mejorada ==
note over Motor: TIP=1, TFP=1, TCP=1
note over Priority: **Priority Scheduling (expropiativo)**\nConvención: Menor número = Mayor prioridad\nExpropiación: prio(nuevo) > prio(actual)\nAging: DESACTIVADO en este ejemplo\nTie-breaking: FIFO entre iguales prioridades
note over Estado: memoriaDisponible=1000, umbralSuspension=100
note over P1: P1: arribo=0, rafagas=3, CPU=5, IO=4, **prio=2**, tamaño=150
note over P2: P2: arribo=1, rafagas=2, CPU=6, IO=3, **prio=1** (MAYOR), tamaño=200
note over P3: P3: arribo=3, rafagas=4, CPU=3, IO=2, **prio=3** (MENOR), tamaño=100
note over P4: P4: arribo=5, rafagas=3, CPU=4, IO=2, **prio=2**, tamaño=250
note over P5: P5: arribo=6, rafagas=2, CPU=7, IO=5, **prio=1** (MAYOR), tamaño=180

note over of Motor: **Orden eventos simultáneos:**\n1.FIN_PROCESO 2.FIN_RAFAGA_CPU 3.EXPROPIACION\n4.FIN_IO 5.FIN_TIP 6.DISPATCH

== Bucle Principal Priority Scheduling ==

loop while EventQueue not empty
    Motor -> EQ: popNext() [orden prioridad académica] 
    EQ --> Motor: evento
    Motor -> Logger: registrar(t, tipo, pid, descripcion)

group t=0: JOB_LLEGA P1 (prioridad 0)
    Motor -> Estado: haySuficienteMemoria(150)
    Estado -> Motor: true
    ref over Motor, Estado : aplicarTIP(P1)\nNUEVO -> intermedio (t += TIP)
    Motor -> EQ: schedule(FIN_TIP, 1, "P1") [prioridad 5]
    Motor -> Logger: registrar(0, "JOB_LLEGA", "P1", "arribo prio=2")
end

group t=1: FIN_TIP P1 + JOB_LLEGA P2 (eventos simultáneos)
    note right: **Orden:** JOB_LLEGA(0) antes que FIN_TIP(5)
    
    == Procesamiento JOB_LLEGA P2 primero ==
    Motor -> Estado: haySuficienteMemoria(200)
    Estado -> Motor: true
    ref over Motor, Estado : aplicarTIP(P2)\nNUEVO -> intermedio (t += TIP)
    Motor -> EQ: schedule(FIN_TIP, 2, "P2") [prioridad 5]
    Motor -> Logger: registrar(1, "JOB_LLEGA", "P2", "arribo prio=1 MAYOR")
    
    == Procesamiento FIN_TIP P1 después ==
    Motor -> P1: estado = NUEVO → LISTO
    Motor -> Estado: reservarMemoria(150) → 850 disponible
    Motor -> RQ: push(P1) [ordenado por prioridad]
    Motor -> Logger: registrar(1, "N->L", "P1", "TIP completado prio=2")
    
    == Auto-dispatch ==
    Motor -> EQ: schedule(DISPATCH, 1, "") [prioridad 6]
    
    == Procesamiento DISPATCH ==
    Motor -> Priority: elegirSiguiente([P1], 1)
    Priority -> Motor: P1 [única opción, prio=2]
    Motor -> RQ: remove(P1)
    ref over Motor, CPU : aplicarTCP()\nLISTO -> CORRIENDO (t += TCP)
    Motor -> P1: estado = LISTO → CORRIENDO
    Motor -> CPU: asignar(P1)
    Motor -> Estado: procesoEnCPU = P1
    Motor -> EQ: schedule(FIN_RAFAGA_CPU, 7, "P1") [t+TCP+5=7, prioridad 2]
    Motor -> Logger: registrar(1, "L->C", "P1", "dispatch + TCP")
end

group t=2: FIN_TIP P2 - EXPROPIACIÓN POR PRIORIDAD
    Motor -> P2: estado = NUEVO → LISTO
    Motor -> Estado: reservarMemoria(200) → 650 disponible
    Motor -> RQ: push(P2) [ordenado por prioridad: P2(1) antes que P1]
    Motor -> Logger: registrar(2, "N->L", "P2", "TIP completado prio=1")
    
    == Evaluación de expropiación ==
    Motor -> Priority: evaluarExpropiacion(P2_prio=1, P1_actual_prio=2)
    Priority -> Motor: true [prio(P2=1) > prio(P1=2)]
    
    alt [prio(nuevo) > prio(actual)] P2 puede expropiar a P1
        Motor -> P1: estado = CORRIENDO → LISTO
        Motor -> CPU: liberar()
        Motor -> RQ: push(P1) [reinserta en cola por prioridad]
        Motor -> EQ: cancel(FIN_RAFAGA_CPU, "P1") [cancelar timer ráfaga]
        Motor -> Logger: registrar(2, "C->L", "P1", "expropiado por mayor prioridad")
        
        == Dispatch automático del proceso expropiante ==
        Motor -> EQ: schedule(DISPATCH, 2, "") [prioridad 6]
        
        == Procesamiento DISPATCH P2 ==
        Motor -> Priority: elegirSiguiente([P2, P1], 2)
        Priority -> Motor: P2 [mayor prioridad: prio=1]
        Motor -> RQ: remove(P2) [cola queda = [P1]]
        ref over Motor, CPU : aplicarTCP()\nLISTO -> CORRIENDO (t += TCP)
        Motor -> P2: estado = LISTO → CORRIENDO
        Motor -> CPU: asignar(P2)
        Motor -> Estado: procesoEnCPU = P2
        Motor -> EQ: schedule(FIN_RAFAGA_CPU, 9, "P2") [t+TCP+6=9, prioridad 2]
        Motor -> Logger: registrar(2, "L->C", "P2", "dispatch tras expropiación")
        note right: **Priority Guard:** [prio(P2=1) > prio(P1=2)] ✓
    end
end

group Ejemplo: FIN_IO con expropiación
    note over Motor: **Caso:** Proceso sale de I/O con mayor prioridad
    
    alt [FIN_IO y prio(liberado) > prio(actual)]
        Motor -> BQ: remove(pid_io)
        Motor -> RQ: push(pid_io) [ordenado por prioridad]
        Motor -> Logger: registrar(t, "B->L", pid_io, "I/O completado")
        
        Motor -> Priority: evaluarExpropiacion(prio_io, prio_actual)
        Priority -> Motor: true [mayor prioridad]
        
        Motor -> CPU: expropiar(proceso_actual)
        Motor -> RQ: push(proceso_actual) [reinserta por prioridad]
        Motor -> EQ: cancel(FIN_RAFAGA_CPU, proceso_actual)
        Motor -> Logger: registrar(t, "C->L", proceso_actual, "expropiado por FIN_IO")
        
        Motor -> EQ: schedule(DISPATCH, t, "") [dispatch inmediato]
        note right: **Priority Guard:** [prio(I/O) > prio(CPU)] ✓
    end
end

group Ejemplo: Aging (si está activado)
    note over Motor: **Aging:** Incremento periódico de prioridad
    
    opt [aging activo cada Δt]
        loop every aging_interval
            Motor -> Priority: aplicarAging()
            Priority -> RQ: incrementarPrioridades() [mejora prioridad procesos antiguos]
            Priority -> Motor: reordenarCola()
            
            opt [cambio de orden por aging]
                Motor -> Priority: evaluarExpropiacion(nuevas_prioridades)
                Priority -> Motor: resultado_expropiacion
                
                alt [hay expropiación por aging]
                    Motor -> CPU: expropiar(proceso_actual)
                    Motor -> EQ: schedule(EXPROPIACION, t, proceso_actual) [prioridad 3]
                    Motor -> Logger: registrar(t, "AGING_PREEMPT", "", "expropiación por aging")
                end
            end
        end
    end
end

note over Motor, Logger: **Priority Scheduling continúa**\n• Expropiación por mayor prioridad (ARRIBO/FIN_IO)\n• Aging opcional para evitar inanición\n• Orden por prioridad + FIFO para empates\n• Cancelación de timers en expropiación

group
    Motor -> ReadyQ: agregar P2
    Motor -> Priority: debeExpropiar(P1, P2, 2)
    Priority -> Priority: P2.prio(1) < P1.prio(2) → true
    Motor -> Evento: programar EXPROPIACION(2, prioridad 3)
    
    == Procesamiento EXPROPIACION (prioridad 3) ==
    Motor -> P1: estado = CORRIENDO → LISTO
    Motor -> P1: actualizar restanteCPU = 4u
    Motor -> ReadyQ: insertar P1 ordenado por prioridad
    Motor -> Priority: elegirSiguiente([P2, P1], 2)
    Priority -> Motor: P2 (prio=1 > prio=2)
    Motor -> P2: estado = LISTO → CORRIENDO + TCP
    Motor -> Estado: procesoEnCPU = P2
    Motor -> Evento: programar FIN_RAFAGA_CPU(9, prioridad 2)
end

group t=3: Arribo P3
    Sys -> P3: JOB_LLEGA
    P3 -> P3: estado = NUEVO
end

group t=4: P3 entra - BAJA PRIORIDAD  
    Sys -> P3: estado = LISTO
    Sys -> PQ: insertar P3 (prio=3)
    note right: P3 (prio=3) < P2 (prio=1): NO expropia
    Sys -> PQ: [P1(prio=2), P3(prio=3)] ordenada por prioridad
end

group t=5: Arribo P4
    Sys -> P4: JOB_LLEGA
    P4 -> P4: estado = NUEVO
end

group t=6: P4 entra, Arribo P5
    Sys -> P4: estado = LISTO  
    Sys -> PQ: insertar P4 (prio=2)
    Sys -> P5: JOB_LLEGA
    P5 -> P5: estado = NUEVO
    note right: P4 (prio=2) < P2 (prio=1): NO expropia
    Sys -> PQ: [P1(prio=2), P4(prio=2), P3(prio=3)]
end

group t=7: P5 entra - ALTA PRIORIDAD
    Sys -> P5: estado = LISTO
    Sys -> PQ: insertar P5 (prio=1)
    note right: **Priority:** P5 (prio=1) = P2 (prio=1) → NO expropia
    note right: Empate: mantener job actual
    Sys -> PQ: [P5(prio=1), P1(prio=2), P4(prio=2), P3(prio=3)]
end

group t=8: P2 termina ráfaga 1  
    CPU -> P2: fin ráfaga CPU
    P2 -> P2: estado = BLOQUEADO (I/O 3u hasta t=11)
    
    PQ -> CPU: despachar P5 (mayor prioridad disponible)  
    CPU -> P5: estado = CORRIENDO
    P5 -> P5: ejecutar ráfaga 1 (7u)
    Sys -> PQ: [P1(prio=2), P4(prio=2), P3(prio=3)] (P2 en I/O)
end

group t=11: P2 termina I/O - REINGRESO PRIORITARIO
    P2 -> P2: fin I/O, estado = LISTO
    Sys -> PQ: insertar P2 (prio=1)
    note right: **Priority:** P2 (prio=1) > P5 (prio=1 ejecutando)
    note right: Empate mantenido: P5 continúa
    
    Sys -> PQ: [P2(prio=1), P1(prio=2), P4(prio=2), P3(prio=3)]
end

group t=15: P5 termina ráfaga 1
    CPU -> P5: fin ráfaga CPU  
    P5 -> P5: estado = BLOQUEADO (I/O 5u hasta t=20)
    
    PQ -> CPU: despachar P2 (mayor prioridad disponible)
    CPU -> P2: estado = CORRIENDO  
    P2 -> P2: ejecutar ráfaga 2 (6u)
    Sys -> PQ: [P1(prio=2), P4(prio=2), P3(prio=3)] (P5 en I/O)
end

group t=20: P5 termina I/O
    P5 -> P5: fin I/O, estado = LISTO
    Sys -> PQ: insertar P5 (prio=1)
    note right: P5 (prio=1) = P2 (prio=1 ejecutando): NO expropia
    Sys -> PQ: [P5(prio=1), P1(prio=2), P4(prio=2), P3(prio=3)]
end

group t=21: P2 termina ráfaga 2 - FINALIZACIÓN
    CPU -> P2: fin ráfaga CPU
    P2 -> P2: estado = TERMINADO
    Sys -> Sys: **TFP = 1u**
    
    PQ -> CPU: despachar P5 (mayor prioridad disponible)
    CPU -> P5: estado = CORRIENDO
    P5 -> P5: ejecutar ráfaga 2 (7u)  
    Sys -> PQ: [P1(prio=2), P4(prio=2), P3(prio=3)]
end

note right of PQ
**Patrón Priority Scheduling:**
- Expropiación inmediata si nueva prio > actual
- En empate de prioridad: mantener actual  
- Cola ordenada por prioridad (1=alta, 3=baja)
- Riesgo starvation procesos baja prioridad
- Optimal para workloads heterogéneos
- TCP solo en expropiaciones reales
end note

@enduml