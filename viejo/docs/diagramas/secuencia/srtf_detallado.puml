@startuml
title Shortest Remaining Time First (SRTF) Mejorado - Con Estados Suspendidos
participant "AdaptadorSimuladorDominio" as Adaptador
participant "MotorSimulacion" as Motor
participant "EstrategiaSchedulerSrtf" as SRTF
participant "EstadoSistema" as Estado
participant "EventQueue" as EQ
participant "ReadyQ" as RQ
participant "BlockedQ" as BQ
participant "Logger" as Logger
participant "CPU" as CPU
participant "P1" as P1
participant "P2" as P2
participant "P3" as P3
participant "P4" as P4
participant "P5" as P5

== Configuración Inicial Mejorada ==
note over Motor: TIP=1, TFP=1, TCP=1
note over SRTF: **SRTF: Shortest Remaining Time First (expropiativo)**\nCriterio: restanteCPU (ráfaga ACTUAL en ejecución)\nExpropiación: restante(nuevo) < restante(actual)\nTie-breaking: FIFO entre iguales tiempos restantes\nActualización: restante se actualiza conforme ejecuta
note over Estado: memoriaDisponible=1000, umbralSuspension=100
note over P1: P1: arribo=0, rafagas=3, **CPU=5**, IO=4, tamaño=150
note over P2: P2: arribo=1, rafagas=2, **CPU=6**, IO=3, tamaño=200  
note over P3: P3: arribo=3, rafagas=4, **CPU=3**, IO=2, tamaño=100
note over P4: P4: arribo=5, rafagas=3, **CPU=4**, IO=2, tamaño=250
note over P5: P5: arribo=6, rafagas=2, **CPU=7**, IO=5, tamaño=180
note over of Motor: **Orden eventos simultáneos: \n1.FIN_PROCESO 2.FIN_RAFAGA_CPU 3.EXPROPIACION\n4.FIN_IO 5.FIN_TIP 6.DISPATCH

== Bucle Principal SRTF ==

loop while EventQueue not empty
    Motor -> EQ: popNext() [orden prioridad académica]
    EQ --> Motor: evento
    Motor -> Logger: registrar(t, tipo, pid, descripcion)

group t=0: JOB_LLEGA P1 (prioridad 0)
    Motor -> Estado: haySuficienteMemoria(150)
    Estado -> Motor: true
    ref over Motor, Estado : aplicarTIP(P1)\nNUEVO -> intermedio (t += TIP)
    Motor -> EQ: schedule(FIN_TIP, 1, "P1") [prioridad 5]
    Motor -> Logger: registrar(0, "JOB_LLEGA", "P1", "arribo restante=5")
end

group t=1: FIN_TIP P1 + JOB_LLEGA P2 (eventos simultáneos)
    note right: **Orden:** JOB_LLEGA(0) antes que FIN_TIP(5)
    
    == Procesamiento JOB_LLEGA P2 primero ==
    Motor -> Estado: haySuficienteMemoria(200)
    Estado -> Motor: true
    ref over Motor, Estado : aplicarTIP(P2)\nNUEVO -> intermedio (t += TIP)
    Motor -> EQ: schedule(FIN_TIP, 2, "P2") [prioridad 5]
    Motor -> Logger: registrar(1, "JOB_LLEGA", "P2", "arribo restante=6")
    
    == Procesamiento FIN_TIP P1 después ==
    Motor -> P1: estado = NUEVO → LISTO, restanteCPU = 5
    Motor -> Estado: reservarMemoria(150) → 850 disponible
    Motor -> RQ: push(P1) [ordenado por tiempo restante]
    Motor -> Logger: registrar(1, "N->L", "P1", "TIP completado restante=5")
    
    == Auto-dispatch ==
    Motor -> EQ: schedule(DISPATCH, 1, "") [prioridad 6]
    
    == Procesamiento DISPATCH ==
    Motor -> SRTF: elegirSiguiente([P1], 1)
    SRTF -> Motor: P1 [única opción, restanteCPU=5]
    Motor -> RQ: remove(P1)
    ref over Motor, CPU : aplicarTCP()\nLISTO -> CORRIENDO (t += TCP)
    Motor -> P1: estado = LISTO → CORRIENDO
    Motor -> CPU: asignar(P1)
    Motor -> Estado: procesoEnCPU = P1, restanteCPU = 5
    Motor -> EQ: schedule(FIN_RAFAGA_CPU, 7, "P1") [t+TCP+5=7, prioridad 2]
    Motor -> Logger: registrar(1, "L->C", "P1", "dispatch + TCP")
end

group t=2: FIN_TIP P2 - SIN EXPROPIACIÓN
    Motor -> P2: estado = NUEVO → LISTO, restanteCPU = 6
    Motor -> Estado: reservarMemoria(200) → 650 disponible
    Motor -> RQ: push(P2) [ordenado por tiempo restante]
    Motor -> Logger: registrar(2, "N->L", "P2", "TIP completado restante=6")
    
    == Evaluación de expropiación ==
    Motor -> SRTF: evaluarExpropiacion(P2_restante=6, P1_restante_actual=4)
    note right: **P1 ha ejecutado 1 unidad:** restante = 5-1 = 4
    SRTF -> Motor: false [restante(P2=6) NOT < restante(P1=4)]
    
    alt [restante(nuevo) < restante(actual)] NO se cumple
        Motor -> Logger: registrar(2, "NO_PREEMPT", "P2", "restante(6) >= actual(4)")
        note right: **SRTF Guard:** [restante(P2=6) >= restante(P1=4)] ✗
    else [restante(nuevo) < restante(actual)] se cumple
        Motor -> CPU: expropiar(P1)
        Motor -> Logger: registrar(2, "PREEMPT", "P1", "menor tiempo restante")
    end
end

group t=3: JOB_LLEGA P3 - EXPROPIACIÓN POR MENOR TIEMPO RESTANTE
    Motor -> Estado: haySuficienteMemoria(100)
    Estado -> Motor: true
    ref over Motor, Estado : aplicarTIP(P3)\nNUEVO -> intermedio (t += TIP)
    Motor -> EQ: schedule(FIN_TIP, 4, "P3") [prioridad 5]
    Motor -> Logger: registrar(3, "JOB_LLEGA", "P3", "arribo restante=3")
end

group t=4: FIN_TIP P3 - EXPROPIACIÓN CONFIRMADA
    Motor -> P3: estado = NUEVO → LISTO, restanteCPU = 3
    Motor -> Estado: reservarMemoria(100) → 550 disponible
    Motor -> RQ: push(P3) [ordenado por tiempo restante]
    Motor -> Logger: registrar(4, "N->L", "P3", "TIP completado restante=3")
    
    == Evaluación de expropiación ==
    Motor -> SRTF: evaluarExpropiacion(P3_restante=3, P1_restante_actual=2)
    note right: **P1 ha ejecutado 3 unidades:** restante = 5-3 = 2
    SRTF -> Motor: false [restante(P3=3) NOT < restante(P1=2)]
    
    note right: **Ejemplo hipotético:** Si P3 tuviera restante=1
    alt [restante(nuevo) < restante(actual)] ejemplo con P3_restante=1
        Motor -> P1: estado = CORRIENDO → LISTO
        Motor -> CPU: liberar()
        Motor -> RQ: push(P1) [reinserta ordenado por restante]
        Motor -> EQ: cancel(FIN_RAFAGA_CPU, "P1") [cancelar timer actual]
        Motor -> Logger: registrar(4, "C->L", "P1", "expropiado por menor restante")
        
        == Dispatch del proceso expropiante ==
        Motor -> EQ: schedule(DISPATCH, 4, "") [prioridad 6]
        
        == Procesamiento DISPATCH P3 ==
        Motor -> SRTF: elegirSiguiente([P3, P1, P2], 4)
        SRTF -> Motor: P3 [menor tiempo restante]
        Motor -> RQ: remove(P3) [cola = [P1, P2] ordenada por restante]
        ref over Motor, CPU : aplicarTCP()\nLISTO -> CORRIENDO (t += TCP)
        Motor -> P3: estado = LISTO → CORRIENDO
        Motor -> CPU: asignar(P3)
        Motor -> Estado: procesoEnCPU = P3, restanteCPU = 1
        Motor -> EQ: schedule(FIN_RAFAGA_CPU, 6, "P3") [t+TCP+1=6, prioridad 2]
        Motor -> Logger: registrar(4, "L->C", "P3", "dispatch tras expropiación")
        note right: **SRTF Guard:** [restante(P3=1) < restante(P1=2)] ✓
    end
end

group Ejemplo: FIN_IO con expropiación
    note over Motor: **Caso:** Proceso sale de I/O con menor tiempo restante
    
    alt [FIN_IO y restante(liberado) < restante(actual)]
        Motor -> BQ: remove(pid_io)
        Motor -> RQ: push(pid_io) [ordenado por tiempo restante]
        Motor -> Logger: registrar(t, "B->L", pid_io, "I/O completado")
        
        Motor -> SRTF: evaluarExpropiacion(restante_io, restante_actual)
        SRTF -> Motor: true [menor tiempo restante]
        
        Motor -> CPU: expropiar(proceso_actual)
        Motor -> RQ: push(proceso_actual) [reinserta ordenado]
        Motor -> EQ: cancel(FIN_RAFAGA_CPU, proceso_actual)
        Motor -> Logger: registrar(t, "C->L", proceso_actual, "expropiado por FIN_IO")
        
        Motor -> EQ: schedule(DISPATCH, t, "") [dispatch inmediato]
        note right: **SRTF Guard:** [restante(I/O) < restante(CPU)] ✓
    end
end

group Actualización dinámica de tiempo restante
    note over Motor: **Actualización continua durante ejecución**
    
    loop durante ejecución de proceso
        Motor -> Estado: actualizarRestanteCPU(procesoEnCPU, tiempoEjecutado)
        Estado -> Estado: restanteCPU = original - ejecutado
        
        opt cada arribo/fin_io
            Motor -> SRTF: reevaluar() [comparar nuevos restantes]
            alt [hay proceso con menor restante]
                Motor -> EQ: schedule(EXPROPIACION, t, proceso_actual) [prioridad 3]
            end
        end
    end
end

note over Motor, Logger: **SRTF continúa con expropiación dinámica**\n• Comparación continua de tiempos restantes\n• Expropiación en ARRIBO y FIN_IO\n• Actualización de restante durante ejecución\n• Tie-breaking FIFO para empates

group t=0: Arribo P1
    Motor -> ReadyQ: agregar P2
    Motor -> P1: actualizar restanteCPU = 4 (ejecutó 1u)
    Motor -> SRTF: debeExpropiar(P1, P2, 2)
    SRTF -> SRTF: P1.restanteCPU(4) < P2.restanteCPU(6) → false
    note right: **SRTF:** P1 continúa (menor tiempo restante de ráfaga actual)
    Motor -> ReadyQ: [P2] (P1 en CPU con restanteCPU=4)
end

group t=3: Arribo P3
    Motor -> Evento: new EventoMejorado(3, JOB_LLEGA, "P3")
end

group t=4: P3 entra (FIN_TIP) - EVALUAR EXPROPIACIÓN
    Motor -> P3: estado = NUEVO → LISTO, restanteCPU = 3
    Motor -> Estado: reservar memoria(100) → 550 disponible
    Motor -> ReadyQ: agregar P3
    Motor -> P1: actualizar restanteCPU = 3 (ejecutó 3u total)
    Motor -> SRTF: debeExpropiar(P1, P3, 4)
    SRTF -> SRTF: P1.restanteCPU(3) == P3.restanteCPU(3) → false (empate)
    note right: **REGLA ACADÉMICA:** En empates, mantener proceso actual
    Motor -> ReadyQ: [P3, P2] ordenada por restanteCPU
end

group t=5: Arribo P4, P1 remaining=2  
    Sys -> P4: JOB_LLEGA
    P4 -> P4: estado = NUEVO
    note right: P1 ahora tiene remaining=2 (mínimo)
end

group t=6: P1 termina ráfaga, P4 entra, Arribo P5
    CPU -> P1: fin ráfaga CPU (remaining=0)
    P1 -> P1: estado = BLOQUEADO (I/O 4u hasta t=10)
    
    Sys -> P4: estado = LISTO
    Sys -> SQ: insertar P4 (remaining=4)  
    Sys -> P5: JOB_LLEGA
    P5 -> P5: estado = NUEVO
    
    note right: **SRTF:** Seleccionar menor remaining time
    note right: P3(remaining=3) < P4(remaining=4) < P2(remaining=6)
    
    SQ -> CPU: despachar P3 (shortest remaining)
    CPU -> P3: estado = CORRIENDO
    P3 -> P3: remaining=3, ejecutando...
    Sys -> SQ: [P4(remaining=4), P2(remaining=6)] (P1 en I/O)
end

group t=7: P5 entra al sistema
    Sys -> P5: estado = LISTO
    Sys -> SQ: insertar P5 (remaining=7)
    note right: **SRTF:** P3(remaining=2) mínimo, continúa
    Sys -> SQ: [P4(remaining=4), P2(remaining=6), P5(remaining=7)]
end

group t=9: P3 termina ráfaga 1
    CPU -> P3: fin ráfaga CPU (remaining=0)  
    P3 -> P3: estado = BLOQUEADO (I/O 2u hasta t=11)
    
    SQ -> CPU: despachar P4 (shortest remaining available)
    CPU -> P4: estado = CORRIENDO
    P4 -> P4: remaining=4, ejecutando...
    Sys -> SQ: [P2(remaining=6), P5(remaining=7)] (P1, P3 en I/O)
end

group t=10: P1 termina I/O - REINGRESO CON REMAINING=5
    P1 -> P1: fin I/O, estado = LISTO
    P1 -> P1: ráfaga 2 remaining=5
    Sys -> SQ: insertar P1 (remaining=5)
    note right: **SRTF:** P4(remaining=2) < P1(remaining=5) < P2(remaining=6)
    note right: P4 continúa (menor remaining)
    Sys -> SQ: [P1(remaining=5), P2(remaining=6), P5(remaining=7)]
end

group t=11: P3 termina I/O - EXPROPIACIÓN INMEDIATA!
    P3 -> P3: fin I/O, estado = LISTO
    P3 -> P3: ráfaga 2 remaining=3  
    Sys -> SQ: insertar P3 (remaining=3)
    note right: **SRTF CRÍTICO:** P4(remaining=2) vs P3(remaining=3)
    note right: P4 sigue siendo shortest remaining
    Sys -> SQ: [P3(remaining=3), P1(remaining=5), P2(remaining=6), P5(remaining=7)]
end

group t=13: P4 termina ráfaga 1 - CAMBIO DE LÍDER
    CPU -> P4: fin ráfaga CPU (remaining=0)
    P4 -> P4: estado = BLOQUEADO (I/O 2u hasta t=15)
    
    SQ -> CPU: despachar P3 (new shortest remaining)
    CPU -> P3: estado = CORRIENDO  
    P3 -> P3: remaining=3, ejecutando...
    Sys -> SQ: [P1(remaining=5), P2(remaining=6), P5(remaining=7)] (P4 en I/O)
end

group t=15: P4 termina I/O
    P4 -> P4: fin I/O, estado = LISTO
    P4 -> P4: ráfaga 2 remaining=4
    Sys -> SQ: insertar P4 (remaining=4)
    note right: **SRTF:** P3(remaining=1) < P4(remaining=4)  
    note right: P3 mantiene CPU (shortest)
    Sys -> SQ: [P4(remaining=4), P1(remaining=5), P2(remaining=6), P5(remaining=7)]
end

group t=16: P3 termina ráfaga 2
    CPU -> P3: fin ráfaga CPU (remaining=0)
    P3 -> P3: estado = BLOQUEADO (I/O 2u hasta t=18)
    
    SQ -> CPU: despachar P4 (shortest remaining available)
    CPU -> P4: estado = CORRIENDO
    P4 -> P4: remaining=4, ejecutando...  
    Sys -> SQ: [P1(remaining=5), P2(remaining=6), P5(remaining=7)] (P3 en I/O)
end

note right of SQ
**Patrón SRTF Preemptive:**
- Expropiación en cada arribo/retorno I/O
- Compara remaining time vs current job
- Minimiza response time agresivamente  
- Mayor overhead TCP que SJF
- Tracking dinámico remaining times
- Optimal para response time promedio
- High context switch frequency
end note

@enduml