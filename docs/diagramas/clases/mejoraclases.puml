@startuml DiagramaClases_Arquitectura_Optimizada

title "Diagrama de Clases - Arquitectura Optimizada (Motor Unico + Event Log)"

' ===============================
' DOMINIO PURO (sin dependencias)
' ===============================
package "üèõÔ∏è DOMINIO PURO" as domain {
  
  package "üéØ Agregado Ra√≠z" as root {
    class Simulation {
      ' Estado privado del sistema
      -clock: Clock
      -eventQueue: EventQueue
      -cpu: Cpu
      -readyQueue: ReadyQueue
      -scheduler: Scheduler
      -eventLog: SimEvent[] 
      -overheadTotals: OverheadTotals
      --
      ' API p√∫blica simple
      +run(processes: Process[], scheduler: Scheduler): DomainResult
      +getCurrentTime(): number
      +getEventLog(): SimEvent[]
      +getTotals(): OverheadTotals
      --
      ' Manejadores de eventos privados (TIP/TCP/TFP centralizados)
      -handleJobArrival(event: JobArrives): void
      -handleTipDone(event: TipDone): void
      -handleDispatch(event: Dispatch): void
      -handleCpuBurstDone(event: CpuBurstDone): void 
      -handleQuantumExpired(event: QuantumExpired): void
      -handleIoDone(event: IoDone): void
      -handleProcessDone(event: ProcessDone): void
      --
      ' Overhead cobrado en √∫nicos puntos correctos
      -cobrarTIP(process: Process): void
      -cobrarTCP(action: "dispatch"|"preempt"): void 
      -cobrarTFP(process: Process): void
      --
      ' Event log inmutable (fuente de verdad √∫nica)
      -registrarEvento(event: SimEvent): void
      -programarEvento(time: number, type: EventType, pid: string): void
    }
  }
  
  package "üß± Entidades" as entities {
    class Process {
      ' Propiedades inmutables 
      +readonly id: string
      +readonly arrivalTime: number
      +readonly totalCpuTime: number
      +readonly totalIoTime: number
      +readonly priority: number
      +readonly burstCount: number
      --
      ' Estado mutable (solo transiciones v√°lidas)
      +state: ProcessState
      +remainingCpu: number
      +remainingIo: number
      +currentBurst: number
      --
      ' Transiciones de estado (encapsuladas)
      +startTip(time: number): void
      +finishTip(time: number): void
      +run(deltaTime: number): void
      +blockIo(time: number): void
      +finishIo(time: number): void
      +finishCpuBurst(time: number): void
      +finishAll(time: number): void
      --
      ' Consultas de estado
      +isCompleted(): boolean
      +needsIo(): boolean
      +canRun(): boolean
      +getRemainingTotal(): number
      +getCurrentBurstRemaining(): number
    }
  }
  
  package "‚öôÔ∏è Recursos del Sistema" as resources {
    class Clock {
      -currentTime: number
      --
      +now(): number
      +advanceTo(time: number): void
      +tick(delta: number): void
    }
    
    class Cpu {
      -running?: Process
      -busyUntil: number
      -tcpAccumulated: number
      --
      +isIdle(): boolean
      +getCurrentProcess(): Process?
      +dispatch(process: Process, time: number): void
      +preempt(time: number): Process?
      +finishCurrentTask(time: number): Process?
      --
      ' TCP centralizado aqu√≠
      +chargeTCP(action: "dispatch"|"preempt", time: number): number
    }
    
    class ReadyQueue {
      -processes: Process[]
      -policy: SchedulingPolicy
      --
      +push(process: Process): void
      +pop(): Process?
      +peek(): Process?
      +isEmpty(): boolean
      +size(): number
      +reorderByPolicy(): void
      +contains(processId: string): boolean
      +remove(processId: string): Process?
    }
  }
  
  package "üìÖ Sistema de Eventos" as events {
    class EventQueue {
      -queue: PriorityQueue<Event>
      --
      +schedule(event: Event): void
      +nextEvent(): Event?
      +isEmpty(): boolean
      +clear(): void
    }
    
    abstract class Event {
      +readonly time: number
      +readonly type: EventType  
      +readonly processId: string
      +readonly priority: number
      +readonly sequence: number
      --
      +compareTo(other: Event): number
    }
    
    class JobArrives extends Event {
      +readonly process: Process
    }
    
    class TipDone extends Event {}
    class Dispatch extends Event {}
    class CpuBurstDone extends Event {}
    class QuantumExpired extends Event {}
    class IoDone extends Event {}
    class ProcessDone extends Event {}
    
    class PriorityQueue<T> {
      -items: T[]
      -compare: (a: T, b: T) => number
      --
      +enqueue(item: T): void
      +dequeue(): T?
      +peek(): T?
      +isEmpty(): boolean
      +size(): number
    }
  }
  
  package "üéõÔ∏è Estrategias de Planificaci√≥n" as scheduling {
    interface Scheduler {
      +getName(): string
      --
      ' API minimalista y clara
      +pick(readyQueue: ReadyQueue, currentTime: number): Process?
      +shouldPreempt(current: Process, candidate: Process, time: number): boolean
      +onDispatch?(process: Process, time: number): void
      +onQuantumTick?(time: number): void
    }
    
    class FCFSScheduler implements Scheduler {
      +getName(): "FCFS"
      +pick(ready: ReadyQueue, time: number): Process?
      +shouldPreempt(): false
    }
    
    class SJFScheduler implements Scheduler {
      +getName(): "SJF"  
      +pick(ready: ReadyQueue, time: number): Process?
      +shouldPreempt(): false
    }
    
    class SRTFScheduler implements Scheduler {
      +getName(): "SRTF"
      +pick(ready: ReadyQueue, time: number): Process?
      +shouldPreempt(current: Process, candidate: Process): boolean
    }
    
    class PriorityScheduler implements Scheduler {
      +getName(): "PRIORITY"
      +pick(ready: ReadyQueue, time: number): Process?  
      +shouldPreempt(current: Process, candidate: Process): boolean
      --
      ' Aging interno encapsulado
      -applyAging(processes: Process[], currentTime: number): void
    }
    
    class RoundRobinScheduler implements Scheduler {
      -quantum: number
      -quantumRemaining: number
      --
      +getName(): "RR"
      +pick(ready: ReadyQueue, time: number): Process?
      +shouldPreempt(): false
      +onDispatch(process: Process, time: number): void
      +onQuantumTick(time: number): boolean
      --
      ' Quantum interno (no filtra al Simulador)
      -startQuantum(): void
      -tickQuantum(): boolean
      -resetQuantum(): void
    }
  }
  
  package "üìä Tipos de Dominio" as domaintypes {
    enum ProcessState {
      NUEVO
      LISTO  
      CORRIENDO
      BLOQUEADO
      TERMINADO
    }
    
    enum EventType {
      JOB_ARRIVES
      TIP_DONE
      DISPATCH
      CPU_BURST_DONE
      QUANTUM_EXPIRED
      IO_DONE
      PROCESS_DONE
    }
    
    class SimEvent {
      +readonly time: number
      +readonly type: EventType
      +readonly processId: string
      +readonly fromState?: ProcessState
      +readonly toState?: ProcessState
      +readonly cpuDelta?: number
      +readonly overheadDelta?: number
      +readonly ioStart?: number
      +readonly description?: string
    }
    
    class OverheadTotals {
      +tip: number
      +tcp: number
      +tfp: number
      +totalUser: number
      +totalIdle: number
      +makespan: number
    }
    
    class DomainResult {
      +readonly events: SimEvent[]
      +readonly processes: ProcessSnapshot[]
      +readonly totals: OverheadTotals
    }
    
    class ProcessSnapshot {
      +readonly id: string
      +readonly finalState: ProcessState
      +readonly completionTime?: number
      +readonly turnaroundTime?: number
      +readonly waitingTime?: number
      +readonly responseTime?: number
    }
  }
}

' ===============================
' APLICACI√ìN (casos de uso puros)
' ===============================
package "üìã APLICACI√ìN" as application {
  
  package "üéÆ Casos de Uso" as usecases {
    class RunSimulation {
      --
      ' Caso de uso principal
      +execute(workload: WorkloadDTO, config: ConfigDTO): Promise<SimulationResultDTO>
      --
      ' Orquestaci√≥n simple
      -createProcesses(workload: WorkloadDTO): Process[]
      -createScheduler(config: ConfigDTO): Scheduler  
      -runDomainSimulation(processes: Process[], scheduler: Scheduler): DomainResult
      -mapToResultDTO(domainResult: DomainResult): SimulationResultDTO
    }
    
    class BuildGantt {
      --
      ' Mapeo puro desde event log
      +fromEventLog(events: SimEvent[]): GanttDTO
      --
      ' Sin "optimizaci√≥n visual" (eso va en UI)
      -mapEventsToSlices(events: SimEvent[]): GanttSlice[]
      -validateSlices(slices: GanttSlice[]): boolean
    }
    
    class ComputeMetrics {
      --
      ' C√°lculo desde dominio (no re-calcula overheads)
      +fromDomainResult(result: DomainResult): MetricsDTO
      --
      ' Usa solo lo que devuelve el dominio
      -calculateTurnaroundTimes(processes: ProcessSnapshot[]): number[]
      -calculateWaitingTimes(events: SimEvent[]): number[]
      -calculateResponseTimes(events: SimEvent[]): number[]
      -calculateUtilization(totals: OverheadTotals): number
    }
  }
  
  package "üì¶ DTOs de Aplicaci√≥n" as appdtos {
    class WorkloadDTO {
      +processes: ProcessSpecDTO[]
      +metadata: WorkloadMetadataDTO
    }
    
    class ConfigDTO {
      +algorithm: string
      +tip: number
      +tcp: number
      +tfp: number
      +quantum?: number
    }
    
    class SimulationResultDTO {
      +gantt: GanttDTO
      +metrics: MetricsDTO
      +events: EventLogDTO
      +summary: SummaryDTO
    }
    
    class GanttDTO {
      +slices: GanttSlice[]
      +totalTime: number
      +processes: string[]
    }
    
    class MetricsDTO {
      +turnaroundTimes: ProcessMetricDTO[]
      +avgTurnaround: number
      +avgWaiting: number
      +avgResponse: number
      +cpuUtilization: number
      +throughput: number
    }
  }
}

' ===============================
' PUERTOS (interfaces) e INFRAESTRUCTURA
' ===============================
package "üîå PUERTOS" as ports {
  interface WorkloadPort {
    +parse(file: File): Promise<WorkloadDTO>
  }
  
  interface ExportPort {
    +exportGantt(gantt: GanttDTO, format: string): string|Blob
    +exportMetrics(metrics: MetricsDTO, format: string): string|Blob  
  }
  
  interface LogPort {
    +persist(events: SimEvent[]): Promise<void>
    +retrieve(sessionId: string): Promise<SimEvent[]>
  }
}

package "üîß INFRAESTRUCTURA" as infrastructure {
  
  package "üìÅ Parsers" as parsers {
    class WorkloadParser implements WorkloadPort {
      +parse(file: File): Promise<WorkloadDTO>
      --
      -detectFormat(file: File): string
      -parseJson(content: string): WorkloadDTO
      -parseTxt(content: string): WorkloadDTO  
      -parseCsv(content: string): WorkloadDTO
    }
  }
  
  package "üì§ Exporters" as exporters {
    class GanttExporter implements ExportPort {
      +exportGantt(gantt: GanttDTO, format: string): string|Blob
      --
      -toJson(gantt: GanttDTO): string
      -toSvg(gantt: GanttDTO): string
      -toPdf(gantt: GanttDTO): Blob
    }
    
    class MetricsExporter implements ExportPort {
      +exportMetrics(metrics: MetricsDTO, format: string): string|Blob
      --
      -toCsv(metrics: MetricsDTO): string
      -toJson(metrics: MetricsDTO): string
      -toReport(metrics: MetricsDTO): string
    }
  }
  
  package "üè≠ Factories" as factories {
    class ProcessFactory {
      +createFromDTO(specs: ProcessSpecDTO[]): Process[]
      --
      -validateSpec(spec: ProcessSpecDTO): void
      -mapToProcess(spec: ProcessSpecDTO): Process
    }
    
    class SchedulerFactory {
      +createFromConfig(config: ConfigDTO): Scheduler
      --
      -createFCFS(): FCFSScheduler
      -createSJF(): SJFScheduler  
      -createSRTF(): SRTFScheduler
      -createPriority(): PriorityScheduler
      -createRoundRobin(quantum: number): RoundRobinScheduler
    }
  }
}

' ===============================
' UI (solo DTOs, sin clases de dominio)
' ===============================
package "üé® UI" as ui {
  
  package "üß© Componentes" as components {
    class CargaArchivo {
      +archivo?: File
      +loading: boolean
      +error?: string
      --
      +onFileSelected(file: File): void
      +onFileRemoved(): void
      +validateFile(file: File): boolean
    }
    
    class ConfiguracionPanel {
      +config: ConfiguracionDTO
      +validation: ValidationResultDTO
      --
      +onConfigChange(config: ConfiguracionDTO): void
      +validateQuantum(value: number): boolean
      +resetConfig(): void
    }
    
    class GanttVisualizacion {
      +gantt: GanttDTO
      +zoom: number
      +filters: GanttFiltersDTO
      --
      +renderSlices(): void
      +handleZoom(factor: number): void
      +optimizeVisualization(): void
    }
    
    class MetricasPanel {
      +metrics: MetricsDTO
      +comparison?: MetricsComparisonDTO
      --
      +renderMetrics(): void
      +compareWith(other: MetricsDTO): void
      +exportMetrics(format: string): void
    }
  }
  
  package "üìä DTOs de UI" as uidtos {
    class ProcesoSimpleDTO {
      +nombre: string
      +llegada: number  
      +rafaga: number
      +prioridad: number
    }
    
    class ConfiguracionDTO {
      +algoritmo: string
      +tip: number
      +tcp: number
      +tfp: number
      +quantum?: number
    }
    
    class ResultadoVisualizacionDTO {
      +gantt: GanttDTO
      +metrics: MetricsDTO
      +summary: ResumenDTO
    }
  }
}

' ===============================
' RELACIONES ARQUITECT√ìNICAS
' ===============================

' Dominio - Agregado ra√≠z orquesta todo
Simulation *-- Clock : usa
Simulation *-- EventQueue : programa
Simulation *-- Cpu : gestiona
Simulation *-- ReadyQueue : maneja
Simulation o-- Scheduler : aplica estrategia
Simulation ..> SimEvent : registra

' Dominio - Recursos internos
Cpu o-- Process : ejecuta
ReadyQueue o-- "many" Process : contiene
EventQueue *-- PriorityQueue : implementa con
EventQueue o-- "many" Event : almacena

' Dominio - Eventos sellados
Event <|-- JobArrives
Event <|-- TipDone
Event <|-- Dispatch  
Event <|-- CpuBurstDone
Event <|-- QuantumExpired
Event <|-- IoDone
Event <|-- ProcessDone

' Dominio - Estrategias
Scheduler <|.. FCFSScheduler
Scheduler <|.. SJFScheduler
Scheduler <|.. SRTFScheduler  
Scheduler <|.. PriorityScheduler
Scheduler <|.. RoundRobinScheduler

' Aplicaci√≥n usa dominio
RunSimulation ..> Simulation : ejecuta
RunSimulation ..> ProcessFactory : crea procesos
RunSimulation ..> SchedulerFactory : crea scheduler
BuildGantt ..> SimEvent : lee log
ComputeMetrics ..> DomainResult : analiza

' Infraestructura adapta
ProcessFactory ..> Process : instancia
SchedulerFactory ..> Scheduler : crea
WorkloadParser ..|> WorkloadPort : implementa
GanttExporter ..|> ExportPort : implementa
MetricsExporter ..|> ExportPort : implementa

' UI consume DTOs
CargaArchivo ..> WorkloadParser : carga con
ConfiguracionPanel ..> ConfiguracionDTO : configura
GanttVisualizacion ..> GanttDTO : muestra
MetricasPanel ..> MetricsDTO : presenta

' Aplicaci√≥n orquesta puertos
RunSimulation ..> WorkloadPort : carga workloads
RunSimulation ..> ExportPort : exporta resultados

' ===============================
' ANOTACIONES ARQUITECT√ìNICAS
' ===============================

note top of Simulation
**üéØ MOTOR √öNICO (Agregado Ra√≠z)**

**Event Log = √önica Fuente de Verdad**
‚Ä¢ Registra TODOS los cambios de estado
‚Ä¢ Gantt se reconstruye SOLO desde el log
‚Ä¢ M√©tricas calculan SOLO desde el log

**Overheads (un solo lugar):**
‚Ä¢ **TIP:** N‚ÜíL (solo en TipDone)
‚Ä¢ **TCP:** L‚ÜíC (Dispatch) + C‚ÜíL (Preempt)  
‚Ä¢ **TFP:** C‚ÜíT (solo en ProcessDone)

**Sin filtraci√≥n de responsabilidades:**
‚Ä¢ Scheduler decide QU√â ejecutar
‚Ä¢ Simulation ejecuta C√ìMO y CU√ÅNDO
‚Ä¢ Event Log registra QU√â PAS√ì
end note

note bottom of scheduling
**üéõÔ∏è SCHEDULER API LIMPIA**

```ts
interface Scheduler {
  pick(ready: ReadyQueue, time: number): Process?;
  shouldPreempt(current: Process, candidate: Process, time: number): boolean;
  onDispatch?(process: Process, time: number): void; // solo RR
}
```

**Reglas claras:**
‚Ä¢ **SRTF:** shouldPreempt si remainingTotal < current.remainingTotal
‚Ä¢ **Priority:** shouldPreempt si priority > current.priority (con aging)
‚Ä¢ **RR:** NO usa shouldPreempt, programa QuantumExpired en onDispatch
‚Ä¢ **FCFS/SJF:** shouldPreempt = false siempre

**Sin contexto "filtrante":** Scheduler recibe TODO lo que necesita
end note

note top of application  
**üìã APLICACI√ìN PURA (casos de uso)**

**Responsabilidades:**
‚Ä¢ RunSimulation: WorkloadDTO ‚Üí SimulationResultDTO
‚Ä¢ BuildGantt: events ‚Üí GanttDTO (mapeo puro)
‚Ä¢ ComputeMetrics: domainResult ‚Üí MetricsDTO

**NO re-calcula overheads:** usa totals del dominio
**NO "optimiza visual":** eso va en UI
**Solo orquesta:** dominio + adaptadores
end note

note bottom of infrastructure
**üîß INFRAESTRUCTURA (detalles)**

**Puertos/Adaptadores:**
‚Ä¢ WorkloadPort: file ‚Üí WorkloadDTO  
‚Ä¢ ExportPort: DTOs ‚Üí formatos
‚Ä¢ LogPort: persistencia de events

**NUNCA tocan dominio:**
‚Ä¢ Solo DTOs como contratos
‚Ä¢ Process/Scheduler = privados del dominio
‚Ä¢ Factories: DTOs ‚Üí entidades (boundary)
end note

note right of ui
**üé® UI (solo presentaci√≥n)**

**Principios:**
‚Ä¢ Solo DTOs, nunca clases de dominio
‚Ä¢ "Optimizaci√≥n visual" aqu√≠ (zoom, filtros)
‚Ä¢ Estado reactivo en composables

**Flujo de datos:**
Usuario ‚Üí DTOs ‚Üí Application ‚Üí Domain
Domain ‚Üí DTOs ‚Üí UI ‚Üí Usuario
end note

' Archivos a eliminar (redundantes)
note bottom of domain
**üóëÔ∏è ELIMINACIONES (capa core redundante):**

‚Ä¢ `core/AdaptadorSimuladorDominio` ‚Üí redundante con RunSimulation  
‚Ä¢ `core/SimState` ‚Üí estado privado de Simulation
‚Ä¢ `services/MetricsCalculator` ‚Üí ComputeMetrics (aplicaci√≥n)
‚Ä¢ `services/GanttBuilder` ‚Üí BuildGantt (aplicaci√≥n)

**üîÑ MOVIMIENTOS:**
‚Ä¢ `entities/Simulador` ‚Üí `domain/core/Simulation` (reescribir)
‚Ä¢ `core/eventQueue` ‚Üí `domain/events/EventQueue`  
‚Ä¢ `core/priorityQueue` ‚Üí implementaci√≥n interna EventQueue
‚Ä¢ `algorithms/` ‚Üí `domain/scheduling/` (sin cambios API)

**‚ú® NUEVOS:**
‚Ä¢ `domain/core/Clock`, `domain/core/Cpu`, `domain/core/ReadyQueue`
‚Ä¢ `application/dto.ts` (todos los DTOs)
‚Ä¢ `infrastructure/factories/` (ProcessFactory, SchedulerFactory)
end note

@enduml
