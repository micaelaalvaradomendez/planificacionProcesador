@startuml PRIORITY_Algoritmo_Mejorado
title Priority Scheduling - Implementación Mejorada con Estados Suspendidos

start

:MotorSimulacionMejorado requiere selección/evaluación;

note right
**Eventos disparadores en Motor Mejorado:**
• CPU libre + Ready Queue no vacía
• FIN_TIP (prioridad 5)
• FIN_IO (prioridad 4)
• Solo si hay memoria suficiente
end note

if (¿Ready Queue vacía?) then (SÍ)
  :CPU permanece idle;
  :Activar procesos LISTO_SUSPENDIDO si hay memoria;
  stop
endif

:Aplicar aging si habilitado (solo procesos LISTO);
note right
**Aging Mejorado:**
• Solo para procesos en estado LISTO
• LISTO_SUSPENDIDO NO participan
• Previene starvation académicamente
end note

:proceso = elegirSiguiente(colaListos, tiempoActual);
note right
**Convención Académica:**
• Menor número = Mayor prioridad
• prioridad 1 > prioridad 2 > ... > prioridad N
• EstrategiaSchedulerPrioridad.ts
end note

if (¿CPU ocupada y modo expropiativo?) then (SÍ)
  :procesoActual = estadoSistema.procesoEnCPU;
  :debeExpropiar = strategy.debeExpropiar(actual, candidato, tiempo);
  if (¿proceso.prioridad < procesoActual.prioridad?) then (SÍ - Mayor prioridad)
    :Programar EventoMejorado EXPROPIACION (prioridad 3);
    :procesoActual.estado = CORRIENDO → LISTO;
    note right
    **Expropiación Mejorada:**
    • TCP se aplicará en próximo DISPATCH
    • Orden de eventos garantizado
    • Insertar en Ready Queue correctamente
    end note
  elseif (¿proceso.prioridad == procesoActual.prioridad?) then (EMPATE)
    :Mantener procesoActual en CPU;
    note right: **REGLA ACADÉMICA CRÍTICA**\nEn empates: NO expropiar
    stop
  else (procesoActual tiene mayor prioridad)
    :Proceso espera en Ready Queue;
    stop
  endif
endif

:Remover proceso de Ready Queue;

:proceso.estado = LISTO → CORRIENDO;

:Aplicar TCP (ÚNICO lugar en Priority);
note right: **TCP MEJORADO**\nSolo en LISTO → CORRIENDO

:estadoSistema.procesoEnCPU = proceso;

:Programar EventoMejorado FIN_RAFAGA_CPU (prioridad 2);

if (¿Presión de memoria?) then (SÍ)
  :Evaluar suspensión de procesos de menor prioridad;
  note right
  **Gestión Memoria Inteligente:**
  • Suspender procesos baja prioridad primero
  • Mantener procesos críticos en memoria
  end note
endif

stop

note left of start
**Priority Mejorado - Implementación Actual:**
• ✅ EstrategiaSchedulerPrioridad.ts (219 líneas)
• ✅ Estados suspendidos integrados
• ✅ Aging solo para procesos LISTO
• ✅ Convención: menor número = mayor prioridad
• ✅ Empates: mantener proceso actual

**Características Académicas:**
• ✅ Expropiación estricta por prioridad
• ✅ Aging configurable contra starvation
• ✅ Tie-breaker por orden de llegada
• ✅ Gestión de memoria por prioridad

**Eventos TCP:**
• ✅ LISTO → CORRIENDO (siempre)
• ❌ CORRIENDO → BLOQUEADO (instantáneo)
• ❌ CORRIENDO → LISTO (TCP pendiente)
• ✅ Estados suspendidos (instantáneo)
✗ Empate de prioridades
✗ Proceso menor prioridad arriba
end note


' === VERSIÓN SIMPLIFICADA ===

title Priority Scheduling

start

:Evento requiere evaluacion;

if (Ready Queue vacia?) then (SI)
  :CPU permanece idle;
  stop
endif

:Ordenar Ready Queue por prioridad;

:proceso = proceso con mayor prioridad;

if (CPU ocupada y modo expropiativo?) then (SI)
  :procesoActual = procesoEnCPU;
  if (proceso.prioridad > procesoActual.prioridad?) then (SI)
    :Expropiar procesoActual;
    :procesoActual.estado = CORRIENDO -> LISTO;
    :Aplicar TCP por expropiacion;
    :Insertar procesoActual en Ready Queue;
  else (NO)
    :Proceso espera en Ready Queue;
    stop
  endif
endif

:Remover proceso de Ready Queue;

:proceso.estado = LISTO -> CORRIENDO;

:Aplicar TCP;

:procesoActualCPU = proceso;

:Programar FIN_RAFAGA_CPU;

stop

note right
Priority Scheduling:
- Mayor valor numerico = mayor prioridad
- Expropiacion inmediata si nueva prio > actual
- En empate: mantener proceso actual
- TCP en despacho L->C y expropiaciones
- Riesgo starvation procesos baja prioridad
end note


@enduml
