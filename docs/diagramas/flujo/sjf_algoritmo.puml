@startuml SJF_Algoritmo_Mejorado
title Shortest Job First (SJF) - Implementación Mejorada con Estados Suspendidos

start

:MotorSimulacionMejorado requiere selección de proceso;

if (¿Ready Queue vacía?) then (SÍ)
  :CPU permanece idle;
  :Activar procesos LISTO_SUSPENDIDO si hay memoria;
  stop
endif

:proceso = elegirSiguiente(colaListos, tiempoActual);
note right
**EstrategiaSchedulerSjf.elegirSiguiente():**
• Calcula servicio restante = rafagasRestantes × duracionCPU
• Ordena por menor servicio total restante
• Tie-breaker: orden de llegada → alfabético
• Solo procesos LISTO (con memoria)
end note

:proceso.estado = LISTO → CORRIENDO;

:Aplicar TCP (ÚNICO lugar en SJF);
note right: **TCP MEJORADO**\nSolo en LISTO → CORRIENDO

:estadoSistema.procesoEnCPU = proceso;

:Programar EventoMejorado FIN_RAFAGA_CPU (prioridad 2);

note right
**SJF Mejorado - No Expropiativo:**
• Proceso ejecuta hasta completar ráfaga
• NO interrupciones por llegada de procesos
• Estados suspendidos manejados automáticamente
• Gestión de memoria transparente
end note

stop

note left of start  
**SJF Mejorado - Implementación Actual:**
• ✅ EstrategiaSchedulerSjf.ts (70 líneas)
• ✅ Estados suspendidos integrados  
• ✅ No expropiativo (soportaExpropiacion = false)
• ✅ Servicio total restante = rafagasRestantes × duracionCPU
• ✅ Tie-breaker: arribo → orden alfabético

**Características Académicas:**
• ✅ Minimiza tiempo promedio de retorno
• ✅ Puede causar starvation de procesos largos
• ✅ Óptimo para workloads conocidos
• ✅ Gestión transparente de memoria

**Eventos TCP:**
• ✅ LISTO → CORRIENDO (siempre)
• ❌ CORRIENDO → BLOQUEADO (instantáneo)  
• ❌ No hay expropiación
• ✅ Estados suspendidos (instantáneo)

stop

note left of start
**Política SJF:**
• No expropiativo
• Minimiza tiempo promedio de respuesta  
• Predicción basada en servicio total restante
• Reordenación tras cada retorno I/O

**Cálculo Servicio Restante:**
• Total = ráfagas pendientes × duración CPU
• Se recalcula tras cada ráfaga completada
• Procesos largos pueden sufrir starvation

**Optimal Properties:**
• Minimiza average waiting time
• Predictable para workloads conocidos
• No hay expropiación por llegadas nuevas

**Casos TCP:**
✓ Despacho L→C (único)
✗ Llegada proceso más corto
✗ Retorno I/O con menor servicio
end note


' === VERSIÓN SIMPLIFICADA ===

title Shortest Job First (SJF)

start

:Evento requiere seleccion de proceso;

if (Ready Queue vacia?) then (SI)
  :CPU permanece idle;
  stop
endif

:Calcular servicio restante para cada proceso;
note right: servicio = rafagasRestantes x duracionCPU

:Ordenar Ready Queue por servicio restante;

:proceso = proceso con menor servicio;

:Remover proceso de Ready Queue;

:proceso.estado = LISTO -> CORRIENDO;

:Aplicar TCP;

:procesoActualCPU = proceso;

:Programar FIN_RAFAGA_CPU;

stop

note right
SJF Caracteristicas:
- No expropiativo
- Servicio restante = rafagas x duracion CPU
- Minimiza tiempo promedio respuesta
- Reordenacion tras retorno I/O
- TCP solo en despacho L->C
- Puede causar starvation jobs largos
end note


@enduml
