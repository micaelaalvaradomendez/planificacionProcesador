@startuml FCFS_Algoritmo_Unificado
title FCFS - First Come First Served - Flujo de Decisión Completo

start

:Evento requiere selección de proceso;
note right
**Eventos que activan:**
• CPU libre y Ready Queue no vacía
• Proceso termina ráfaga CPU
• Proceso termina I/O
end note

if (¿Ready Queue vacía?) then (SÍ)
  :CPU permanece idle;
  note right: Sin procesos disponibles\npara scheduling
  stop
endif

:Examinar Ready Queue;
note right
**Estructura de Ready Queue:**
• Cola FIFO estricta
• Sin reordenamiento
• Preserva orden temporal de llegada
end note

:proceso = primer elemento de Ready Queue (FIFO);
note right
**FCFS Puro:** 
Orden FIFO de inserción original
Sin consideración de:
• Tiempo CPU restante
• Prioridad
• Tiempo de llegada vs. actual
end note

:Validar estado del proceso;
note right: proceso.estado debe ser LISTO

:Remover proceso de Ready Queue;
note right: readyQueue.shift() o equivalente

:proceso.estado = LISTO → CORRIENDO;
note right: **Transición crítica**\nÚnica que consume TCP

:Aplicar TCP (Tiempo Cambio Contexto);
note right
**TCP se cobra por:**
• Cambio de contexto del SO
• Salvar registros proceso anterior
• Cargar registros proceso nuevo
• Actualizar MMU, etc.
end note

:tiempo += TCP;

:procesoActualCPU = proceso;
note right: Actualizar referencia\nproceso en ejecución

:Programar evento FIN_RAFAGA_CPU;
note right
**tiempo_evento = tiempo_actual + duracionCPU**
Siguiente evento: proceso completará ráfaga actual
end note

:Actualizar estadísticas de despacho;
note right
• Incrementar conteo despachos
• Registrar tiempo inicio ejecución
• Calcular tiempo de espera del proceso
end note

stop

' === CARACTERÍSTICAS Y COMPORTAMIENTO ===

note top of start
  **POLÍTICA FCFS - CARACTERÍSTICAS FUNDAMENTALES**

  **✅ Ventajas:**
  • Simplicidad implementación
  • Determinístico y predecible
  • Fairness temporal (orden llegada)
  • Sin starvation posible
  • Óptimo para batch processing
  • Mínimo overhead scheduling

  **❌ Desventajas:**
  • Efecto convoy (procesos largos bloquean cortos)
  • Tiempo respuesta muy variable
  • No considera urgencia o importancia
  • Puede ser ineficiente para workloads interactivos

  **🔄 Comportamiento Específico:**
  • **No expropiativo:** Proceso ejecuta hasta completar ráfaga
  • **Post-I/O:** Proceso va al final de Ready Queue
  • **TCP:** Solo se cobra en despacho (LISTO → CORRIENDO)
  **Ordenamiento:** FIFO estricto por tiempo de llegada
end note

note bottom of stop
**FLUJO DE CONTROL FCFS**

**1. Activación:** Eventos que requieren nueva selección
**2. Validación:** Verificar disponibilidad de procesos
**3. Selección:** FIFO puro sin reordenamiento  
**4. Despacho:** Aplicar TCP y programar siguiente evento
**5. Control:** Actualizar estado sistema y estadísticas

**Orden Inserción Ready Queue:**
• Proceso nuevo → final cola (tras TIP)
• Proceso post-I/O → final cola (tras I/O)
• **NO** se reordena por ningún criterio

**Casos Especiales:**
• Múltiples procesos llegan simultáneamente: orden por PID o definición
• Ready Queue vacía: CPU idle hasta próximo evento
• Proceso único: sigue aplicando TCP normal
end note

note left of "Programar evento FIN_RAFAGA_CPU"
**EVENTOS PROGRAMADOS**

**FIN_RAFAGA_CPU:**
• Si rafagasRestantes > 0 → CORRIENDO → BLOQUEADO
• Si rafagasRestantes = 0 → CORRIENDO → TERMINADO
• **Ambas transiciones son instantáneas (NO TCP)**

**Manejo Temporal:**
• tiempo_evento = tiempo_actual + TCP + duracionCPU_actual
• TCP incluido para reflejar overhead real
• Precisión temporal crítica para métricas
end note

@enduml