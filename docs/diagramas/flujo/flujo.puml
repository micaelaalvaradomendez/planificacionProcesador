@startuml Flujo_Simulacion_General
title Simulador de Planificación - Flujo General de Ejecución

start

:Inicializar simulador;
:Ready Queue = [];
:Procesos = cola ordenada por arribo;

while (¿Simulación activa?)

  :Procesar próximo evento;
  
  if (¿Tipo evento?) then (JOB_LLEGA)
    :Proceso P arriba;
    :Aplicar TIP;
    :P.estado = NUEVO → LISTO;
    :Agregar P al FINAL de Ready Queue;
  elseif (¿CPU libre y Ready Queue no vacía?) then (SÍ)
    :P = primer proceso de Ready Queue (FIFO);
    :Remover P de Ready Queue;
    :P.estado = LISTO → CORRIENDO;
    :Aplicar TCP;
    :Programar FIN_RAFAGA_CPU;
    :procesoActualCPU = P;
  else (FIN_RAFAGA_CPU)
    :P = procesoActualCPU;
    if (¿P tiene más ráfagas?) then (SÍ)
      :P.estado = CORRIENDO → BLOQUEADO;
      note right: B→L instantáneo, NO TCP
      :Programar FIN_IO en (tiempo + duracionIO);
    else (NO)
      :P.estado = CORRIENDO → TERMINADO;
      :Aplicar TFP;
      :Agregar P a procesosTerminados;
    endif
    :procesoActualCPU = null;
  elseif then (FIN_IO)
    :P vuelve de I/O;
    :P.estado = BLOQUEADO → LISTO;
    note right: **FCFS:** P va al FINAL de Ready Queue
    :Agregar P al FINAL de Ready Queue;
  endif

endwhile

:Calcular estadísticas finales;
:Generar reporte;

stop

note right of start
**Características FCFS:**
• No expropiativo
• FIFO estricto de Ready Queue
• Proceso post-I/O → final de cola
• Simple, predecible
• Puede causar efecto convoy
• TCP solo en L→C
end note

@enduml

@startuml RR_Flowchart
title Round Robin (RR) - Diagrama de Flujo

start

:Inicializar simulador;
:Ready Queue = [];
:quantum = configurado;
:tiempoQuantumRestante = 0;

while (¿Simulación activa?)

  :Procesar próximo evento;
  
  if (¿Tipo evento?) then (JOB_LLEGA)
    :Proceso P arriba;
    :Aplicar TIP;
    :P.estado = NUEVO → LISTO;
    :Agregar P al FINAL de Ready Queue;
  elseif (¿CPU libre y Ready Queue no vacía?) then (SÍ)
    :P = primer proceso de Ready Queue (FIFO);
    :Remover P de Ready Queue;
    :P.estado = LISTO → CORRIENDO;
    :Aplicar TCP;
    :tiempoQuantumRestante = quantum;
    :Programar eventos de ráfaga y quantum;
    :procesoActualCPU = P;
  elseif then (QUANTUM_EXPIRADO)
    :P = procesoActualCPU;
    :P.estado = CORRIENDO → LISTO;
    note right: **RR CRÍTICO:** TCP por expiración quantum
    :Aplicar TCP;
    :Agregar P al FINAL de Ready Queue;
    :procesoActualCPU = null;
    :Cancelar eventos pendientes de P;
  elseif then (FIN_RAFAGA_CPU)
    :P = procesoActualCPU;
    note right: **RR:** Fin natural, NO TCP
    if (¿P tiene más ráfagas?) then (SÍ)
      :P.estado = CORRIENDO → BLOQUEADO;
      :Programar FIN_IO en (tiempo + duracionIO);
    else (NO)
      :P.estado = CORRIENDO → TERMINADO;
      :Aplicar TFP;
      :Agregar P a procesosTerminados;
    endif
    :procesoActualCPU = null;
    :Cancelar quantum pendiente;
  elseif then (FIN_IO)
    :P vuelve de I/O;
    :P.estado = BLOQUEADO → LISTO;
    note right: **RR:** P va al FINAL de Ready Queue
    :Agregar P al FINAL de Ready Queue;
    note right: **Consigna TP:** NO interrumpir quantum actual
  endif

endwhile

:Calcular estadísticas finales;
:Generar reporte;

stop

note right of start
**Características RR:**
• Expropiativo por quantum
• FIFO circular con time slice
• TCP SOLO por expiración quantum
• NO TCP por fin natural de ráfaga
• Fairness garantizado
• Retorno I/O → final cola
• Quantum típico: 4 unidades
end note

@enduml

@startuml Priority_Flowchart
title Priority Scheduling - Diagrama de Flujo

start

:Inicializar simulador;
:Ready Queue = [];
:expropiativo = configurado;

while (¿Simulación activa?)

  :Procesar próximo evento;
  
  if (¿Tipo evento?) then (JOB_LLEGA)
    :Proceso P arriba;
    :Aplicar TIP;
    :P.estado = NUEVO → LISTO;
    :Insertar P en Ready Queue por prioridad;
    if (¿Expropiativo y CPU ocupada?) then (SÍ)
      :P_actual = procesoActualCPU;
      if (¿P.prioridad > P_actual.prioridad?) then (SÍ)
        :Expropiar P_actual;
        :P_actual.estado = CORRIENDO → LISTO;
        :Aplicar TCP (por expropiación);
        :Insertar P_actual en Ready Queue;
        :Despachar P inmediatamente;
        :P.estado = LISTO → CORRIENDO;
        :procesoActualCPU = P;
      endif
    endif
  elseif (¿CPU libre y Ready Queue no vacía?) then (SÍ)
    :Ordenar Ready Queue por prioridad;
    :P = proceso con mayor prioridad;
    :Remover P de Ready Queue;
    :P.estado = LISTO → CORRIENDO;
    :Aplicar TCP;
    :Programar FIN_RAFAGA_CPU;
    :procesoActualCPU = P;
  elseif then (FIN_RAFAGA_CPU)
    :P = procesoActualCPU;
    if (¿P tiene más ráfagas?) then (SÍ)
      :P.estado = CORRIENDO → BLOQUEADO;
      :Programar FIN_IO en (tiempo + duracionIO);
    else (NO)
      :P.estado = CORRIENDO → TERMINADO;
      :Aplicar TFP;
      :Agregar P a procesosTerminados;
    endif
    :procesoActualCPU = null;
  elseif then (FIN_IO)
    :P vuelve de I/O;
    :P.estado = BLOQUEADO → LISTO;
    :Insertar P en Ready Queue por prioridad;
    if (¿Expropiativo y CPU ocupada?) then (SÍ)
      :P_actual = procesoActualCPU;
      if (¿P.prioridad > P_actual.prioridad?) then (SÍ)
        :Expropiar P_actual;
        :P_actual.estado = CORRIENDO → LISTO;
        :Aplicar TCP (por expropiación);
        :Insertar P_actual en Ready Queue;
        :Despachar P inmediatamente;
      endif
    endif
  endif

endwhile

:Calcular estadísticas finales;
:Generar reporte;

stop

note right of start
**Características Priority:**
• Expropiativo/No expropiativo
• Mayor prioridad = valor numérico mayor
• Expropiación inmediata si nueva prio > actual
• En empate: mantener proceso actual
• Riesgo starvation procesos baja prioridad
• TCP solo en expropiaciones reales
end note

@enduml

@startuml SJF_Flowchart
title Shortest Job First (SJF) - Diagrama de Flujo

start

:Inicializar simulador;
:Ready Queue = [];

while (¿Simulación activa?)

  :Procesar próximo evento;
  
  if (¿Tipo evento?) then (JOB_LLEGA)
    :Proceso P arriba;
    :Aplicar TIP;
    :P.estado = NUEVO → LISTO;
    :Insertar P en Ready Queue;
  elseif (¿CPU libre y Ready Queue no vacía?) then (SÍ)
    :Calcular servicio restante para cada proceso;
    note right: servicioRestante = rafagasRestantes × duracionCPU
    :Ordenar Ready Queue por servicio restante;
    :P = proceso con menor servicio restante;
    :Remover P de Ready Queue;
    :P.estado = LISTO → CORRIENDO;
    :Aplicar TCP;
    :Programar FIN_RAFAGA_CPU;
    :procesoActualCPU = P;
  elseif then (FIN_RAFAGA_CPU)
    :P = procesoActualCPU;
    if (¿P tiene más ráfagas?) then (SÍ)
      :P.estado = CORRIENDO → BLOQUEADO;
      :Programar FIN_IO en (tiempo + duracionIO);
    else (NO)
      :P.estado = CORRIENDO → TERMINADO;
      :Aplicar TFP;
      :Agregar P a procesosTerminados;
    endif
    :procesoActualCPU = null;
  elseif then (FIN_IO)
    :P vuelve de I/O;
    :P.estado = BLOQUEADO → LISTO;
    :Insertar P en Ready Queue;
    note right: **SJF:** NO expropia proceso actual
    note right: P espera su turno según servicio restante
  endif

  if (¿Ready Queue tiene procesos?) then (SÍ)
    :Reordenar por servicio restante actualizado;
    note right: Recalcular tras cada retorno I/O
  endif

endwhile

:Calcular estadísticas finales;
:Generar reporte;

stop

note right of start
**Características SJF:**
• No expropiativo
• Servicio restante = ráfagas × duración CPU
• Minimiza tiempo promedio respuesta
• Reordenación tras retorno I/O
• Puede causar starvation jobs largos
• Predice duración próxima ráfaga
• TCP solo en cambios naturales
end note

@enduml

@startuml SRTF_Flowchart
title Shortest Remaining Time First (SRTF) - Diagrama de Flujo

start

:Inicializar simulador;
:Ready Queue = [];

while (¿Simulación activa?)

  :Procesar próximo evento;
  
  if (¿Tipo evento?) then (JOB_LLEGA)
    :Proceso P arriba;
    :Aplicar TIP;
    :P.estado = NUEVO → LISTO;
    :Insertar P en Ready Queue;
    if (¿CPU ocupada?) then (SÍ)
      :P_actual = procesoActualCPU;
      if (¿P.restanteTotalCPU < P_actual.restanteTotalCPU?) then (SÍ)
        :Expropiar P_actual inmediatamente;
        :P_actual.estado = CORRIENDO → LISTO;
        :Aplicar TCP (por expropiación);
        :Insertar P_actual en Ready Queue;
        :Despachar P inmediatamente;
        :P.estado = LISTO → CORRIENDO;
        :procesoActualCPU = P;
      endif
    endif
  elseif (¿CPU libre y Ready Queue no vacía?) then (SÍ)
    :Ordenar Ready Queue por restanteTotalCPU;
    :P = proceso con menor tiempo restante;
    :Remover P de Ready Queue;
    :P.estado = LISTO → CORRIENDO;
    :Aplicar TCP;
    :Programar FIN_RAFAGA_CPU;
    :procesoActualCPU = P;
  elseif then (FIN_RAFAGA_CPU)
    :P = procesoActualCPU;
    :Actualizar P.restanteTotalCPU;
    if (¿P tiene más ráfagas?) then (SÍ)
      :P.estado = CORRIENDO → BLOQUEADO;
      :Programar FIN_IO en (tiempo + duracionIO);
    else (NO)
      :P.estado = CORRIENDO → TERMINADO;
      :Aplicar TFP;
      :Agregar P a procesosTerminados;
    endif
    :procesoActualCPU = null;
  elseif then (FIN_IO)
    :P vuelve de I/O;
    :P.estado = BLOQUEADO → LISTO;
    :Insertar P en Ready Queue;
    if (¿CPU ocupada?) then (SÍ)
      :P_actual = procesoActualCPU;
      if (¿P.restanteTotalCPU < P_actual.restanteTotalCPU?) then (SÍ)
        :Expropiar P_actual inmediatamente;
        :P_actual.estado = CORRIENDO → LISTO;
        :Aplicar TCP (por expropiación);
        :Insertar P_actual en Ready Queue;
        :Despachar P inmediatamente;
      endif
    endif
  endif

  :Actualizar restanteTotalCPU de proceso actual;
  :Reordenar Ready Queue si es necesario;

endwhile

:Calcular estadísticas finales;
:Generar reporte;

stop

note right of start
**Características SRTF:**
• Expropiativo agresivo
• Comparación continua remaining time
• Expropiación en cada arribo/retorno I/O
• Minimiza response time promedio
• Mayor overhead TCP que SJF
• Tracking dinámico tiempos restantes
• Optimal para response time
end note

@enduml

@startuml General_Sistema_Flowchart
title Sistema General - Gestión de Estados y Eventos

start

:Configurar parámetros simulación;
:TIP, TFP, TCP, quantum (si RR);
:Inicializar estructuras de datos;

:Cargar procesos en sistema;
:Crear eventos JOB_LLEGA por arribo;

while (¿Cola eventos no vacía?)

  :evento = próximo evento cronológico;
  :Avanzar tiempoActual = evento.tiempo;

  if (¿Tipo evento?) then (JOB_LLEGA)
    :Proceso P arriba al sistema;
    :P.estado = NUEVO;
    :Esperar TIP unidades de tiempo;
    :P.estado = NUEVO → LISTO;
    :Aplicar política de inserción Ready Queue;
    
  elseif then (CPU_IDLE)
    if (¿Ready Queue vacía?) then (SÍ)
      :CPU permanece idle;
      :Contabilizar tiempo inactivo;
    else (NO)
      :Seleccionar proceso según algoritmo;
      :Despachar a CPU;
    endif
    
  elseif then (FIN_RAFAGA_CPU)
    :P = proceso que termina ráfaga;
    :P.rafagasRestantes--;
    :Actualizar estadísticas CPU;
    
    if (¿P.rafagasRestantes > 0?) then (SÍ)
      :P.estado = CORRIENDO → BLOQUEADO;
      note left: **Crítico:** B→L instantáneo, NO TCP
      :Programar FIN_IO(tiempo + duracionIO);
      :P inicia operación I/O;
    else (NO)
      :P.estado = CORRIENDO → TERMINADO;
      :Aplicar TFP;
      :Contabilizar métricas finales P;
    endif
    
    :CPU queda libre;
    :procesoActualCPU = null;
    
  elseif then (FIN_IO)
    :P termina operación I/O;
    :P.estado = BLOQUEADO → LISTO;
    note left: **Crítico:** Transición instantánea
    :Insertar P en Ready Queue según algoritmo;
    
    if (¿Algoritmo expropiativo?) then (SÍ)
      :Evaluar expropiación inmediata;
      if (¿Debe expropiar proceso actual?) then (SÍ)
        :Expropiar proceso actual;
        :Aplicar TCP por expropiación;
        :Despachar P inmediatamente;
      endif
    endif
    
  elseif then (QUANTUM_EXPIRADO)
    note right: Solo para Round Robin
    :P = proceso con quantum expirado;
    :P.estado = CORRIENDO → LISTO;
    :Aplicar TCP por expropiación;
    :Insertar P al final Ready Queue;
    :CPU queda libre;
    
  endif

  if (¿CPU libre y Ready Queue no vacía?) then (SÍ)
    :Seleccionar proceso según algoritmo;
    :Aplicar TCP (L→C);
    :Despachar a CPU;
  endif

endwhile

if (¿Todos procesos terminados?) then (NO)
  :ERROR: Simulación incompleta;
  stop
endif

:Calcular estadísticas globales;
:Generar timeline Gantt;
:Producir reporte final;

stop

note right of start
**Eventos del Sistema:**
• JOB_LLEGA: Arribo proceso
• FIN_RAFAGA_CPU: Termina ejecución
• FIN_IO: Termina operación I/O
• QUANTUM_EXPIRADO: Solo RR

**Estados Críticos:**
• NUEVO → LISTO: TIP
• LISTO → CORRIENDO: TCP
• CORRIENDO → BLOQUEADO: 0u
• BLOQUEADO → LISTO: 0u
• CORRIENDO → TERMINADO: TFP

**TCP se aplica ÚNICAMENTE:**
• Despacho: LISTO → CORRIENDO
• Expropiación por quantum (RR)
• Expropiación por prioridad/SRTF
end note

@enduml