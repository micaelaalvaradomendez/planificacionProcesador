@startuml SRTF_Algoritmo_Mejorado
title Shortest Remaining Time First (SRTF) - Implementación Mejorada con Estados Suspendidos

start

:MotorSimulacionMejorado requiere evaluación SRTF;

note right
**Eventos disparadores en Motor Mejorado:**
• FIN_TIP (prioridad 5)
• FIN_IO (prioridad 4) 
• CPU libre + Ready Queue no vacía
• Solo procesos con memoria disponible
end note

if (¿Ready Queue vacía?) then (SÍ)
  :CPU permanece idle;
  :Activar procesos LISTO_SUSPENDIDO si hay memoria;
  stop
endif

:proceso = elegirSiguiente(colaListos, tiempoActual);
note right
**EstrategiaSchedulerSrtf.elegirSiguiente():**
• Usa restanteCPU (ráfaga ACTUAL)
• NO restanteTotalCPU (tiempo total)
• Tie-breaker: orden de llegada
• Solo procesos LISTO (con memoria)
end note

if (¿CPU ocupada?) then (SÍ)
  :procesoActual = estadoSistema.procesoEnCPU;
  :debeExpropiar = strategy.debeExpropiar(actual, candidato, tiempo);
  
  if (¿proceso.restanteCPU < procesoActual.restanteCPU?) then (SÍ)
    :Programar EventoMejorado EXPROPIACION (prioridad 3);
    note right
    **SRTF Expropiación Mejorada:**
    • Usa restanteCPU (ráfaga actual)
    • TCP pendiente para próximo DISPATCH
    • Orden de eventos garantizado
    end note
    :procesoActual.estado = CORRIENDO → LISTO;
    :Insertar procesoActual en Ready Queue;
  elseif (¿proceso.restanteCPU == procesoActual.restanteCPU?) then (EMPATE)
    :Mantener procesoActual en CPU;
    note right: **REGLA ACADÉMICA CRÍTICA**\nEn empates: NO expropiar
    stop
  else (procesoActual tiene menor tiempo restante)
    :Proceso espera en Ready Queue;
    stop
  endif
endif

:Remover proceso de Ready Queue;

:proceso.estado = LISTO → CORRIENDO;

:Aplicar TCP;
note right: TCP en despacho L→C o expropiación

:procesoActualCPU = proceso;

:Programar FIN_RAFAGA_CPU;

:Inicializar tracking tiempo restante;
note right: **Tracking Dinámico:**
Actualizar restanteTotalCPU cada unidad tiempo
end note

:Actualizar estadísticas;

stop

note left of start
**SRTF Mejorado - Implementación Actual:**
• ✅ EstrategiaSchedulerSrtf.ts (112 líneas)
• ✅ Estados suspendidos integrados
• ✅ Expropiativo agresivo por restanteCPU
• ✅ Empates: mantener proceso actual
• ✅ Óptimo para tiempo promedio de respuesta

**Reglas Académicas:**
• ✅ Usa restanteCPU (ráfaga actual)
• ✅ NO restanteTotalCPU (tiempo total)
• ✅ Expropiación solo si strictly menor
• ✅ Evaluación en FIN_TIP y FIN_IO
• ✅ Gestión transparente de memoria

**Eventos TCP:**
• ✅ LISTO → CORRIENDO (siempre)
• ❌ CORRIENDO → BLOQUEADO (instantáneo)
• ❌ CORRIENDO → LISTO (TCP pendiente)
• ✅ Estados suspendidos (instantáneo)

**Casos TCP:**
✓ Despacho L→C
✓ Expropiación por menor remaining time  
✗ Empate de tiempos restantes
✗ Proceso mayor remaining time arriba
end note


' === VERSIÓN SIMPLIFICADA ===

title Shortest Remaining Time First (SRTF)

start

:Evento requiere evaluacion SRTF;

if (Ready Queue vacia?) then (SI)
  :CPU permanece idle;
  stop
endif

:Ordenar Ready Queue por restanteTotalCPU;

:proceso = proceso con menor tiempo restante;

if (CPU ocupada?) then (SI)
  :procesoActual = procesoEnCPU;
  if (proceso.restanteTotalCPU < procesoActual.restanteTotalCPU?) then (SI)
    :Expropiar procesoActual inmediatamente;
    :procesoActual.estado = CORRIENDO -> LISTO;
    :Aplicar TCP por expropiacion;
    :Insertar procesoActual en Ready Queue;
  else (NO)
    :Proceso espera en Ready Queue;
    stop
  endif
endif

:Remover proceso de Ready Queue;

:proceso.estado = LISTO -> CORRIENDO;

:Aplicar TCP;

:procesoActualCPU = proceso;

:Programar FIN_RAFAGA_CPU;

stop

note right
SRTF Caracteristicas:
- Expropiativo agresivo
- Comparacion continua remaining time
- Expropiacion en cada arribo/retorno I/O
- Minimiza response time promedio
- Mayor overhead que SJF
- TCP en despacho L->C y expropiaciones
end note


@enduml
