@startuml RR_Algoritmo_Mejorado
title Round Robin - Implementación Mejorada con Estados Suspendidos

start

:MotorSimulacionMejorado requiere selección de proceso;

if (¿Ready Queue vacía?) then (SÍ)
  :CPU permanece idle;
  :Activar procesos suspendidos si hay memoria;
  note right: **NUEVA CARACTERÍSTICA**\nRevisar LISTO_SUSPENDIDO
  stop
endif

:Examinar Ready Queue (solo procesos LISTO);
note right
**Ready Queue Mejorada:**
• Solo procesos con memoria asignada
• LISTO_SUSPENDIDO NO incluidos
• FIFO circular mantenido
end note

:proceso = elegirSiguiente(colaListos, tiempoActual);
note right: **RR Mejorado:** EstrategiaSchedulerRoundRobin

:Remover proceso de Ready Queue;

:proceso.estado = LISTO → CORRIENDO;

:Aplicar TCP (ÚNICO lugar en RR);
note right: **TCP MEJORADO**\nSolo en LISTO → CORRIENDO\nNUNCA en otras transiciones

:estadoSistema.procesoEnCPU = proceso;
:tiempoInicioQuantum = tiempoActual;

:Programar EventoMejorado con prioridades;
note right
**Eventos con Prioridad Académica:**
• FIN_RAFAGA_CPU: prioridad 2
• QUANTUM_EXPIRES: prioridad 3 (expropiación)
• Orden correcto garantizado
end note

:Motor procesa próximo EventoMejorado (orden prioridad);

switch (Tipo de evento procesado primero)
case (FIN_RAFAGA_CPU - Prioridad 2)
  if (¿Más ráfagas?) then (SÍ)
    :estado = CORRIENDO → BLOQUEADO;
    note right: **INSTANTÁNEO - NO TCP**
    :Programar FIN_IO;
    if (¿Hay suficiente memoria?) then (NO)
      :estado = BLOQUEADO → BLOQUEADO_SUSPENDIDO;
      :Liberar memoria del proceso;
    endif
  else (NO)
    :estado = CORRIENDO → TERMINADO;
    :Aplicar TFP + liberar memoria;
    :Activar procesos suspendidos;
  endif
  
case (QUANTUM_EXPIRES - Prioridad 3)
  :estado = CORRIENDO → LISTO;
  note right: **TCP PENDIENTE**\nSe cobrará en próximo DISPATCH
  :Agregar proceso al FINAL de Ready Queue;
  :Actualizar tiempo restante ráfaga;
  if (¿Presión de memoria?) then (SÍ)
    :Evaluar suspensión por memoria;
  endif
  
endswitch

:estadoSistema.procesoEnCPU = null;
:verificarEstadoCPU();
:evaluarDispatchInmediato();

stop

note left of start
**RR Mejorado - Características:**
• ✅ Estados suspendidos integrados
• ✅ Gestión automática de memoria
• ✅ Orden de eventos con prioridad académica
• ✅ TCP solo en LISTO → CORRIENDO
• ✅ Quantum no interrumpido por retorno I/O

**Implementación Actual:**
• EstrategiaSchedulerRoundRobin.ts
• Integrada con MotorSimulacionMejorado
• Soporte completo para suspensión
• 155 líneas de implementación

**Eventos TCP:**
• ✅ LISTO → CORRIENDO (siempre)
• ❌ CORRIENDO → BLOQUEADO (instantáneo)
• ❌ CORRIENDO → LISTO (TCP pendiente)
• ✅ Estados suspendidos (instantáneo)
✓ Despacho L→C
✓ Expiración quantum
✗ Fin natural ráfaga
✗ Retorno I/O
end note


' === VERSIÓN SIMPLIFICADA ===

title Round Robin - Quantum Scheduling

start

:Evento requiere seleccion de proceso;

if (Ready Queue vacia?) then (SI)
  :CPU permanece idle;
  stop
endif

:proceso = primer elemento Ready Queue;

:Remover proceso de Ready Queue;

:proceso.estado = LISTO -> CORRIENDO;

:Aplicar TCP;

:procesoActualCPU = proceso;

:Iniciar quantum timer;

:Programar FIN_RAFAGA_CPU y QUANTUM_EXPIRADO;

if (Que evento ocurre primero?) then (FIN_RAFAGA_CPU)
  :Rafaga termina naturalmente;
  note right: NO hay TCP
  if (Mas rafagas?) then (SI)
    :estado = CORRIENDO -> BLOQUEADO;
  else (NO)
    :estado = CORRIENDO -> TERMINADO;
  endif
elseif (QUANTUM_EXPIRADO) then
  :Quantum expira;
  :estado = CORRIENDO -> LISTO;
  :Aplicar TCP por expropiacion;
  :Agregar proceso al final Ready Queue;
endif

:CPU queda libre;

stop

note right
Round Robin:
- Quantum fijo (ej: 4 unidades)
- TCP SOLO por expiracion quantum
- NO TCP por fin natural rafaga
- Cola circular FIFO
- Garantiza fairness
end note


@enduml
