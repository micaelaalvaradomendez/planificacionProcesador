@startuml
title Priority Scheduling - Secuencia Corregida con Expropiación por Prioridad
participant "Motor" as Motor
participant "P1" as P1
participant "P2" as P2  
participant "P3" as P3
participant "CPU" as CPU
participant "ReadyQueue" as RQ
participant "EventLogger" as Log

== Configuración Priority Scheduling ==
note over Motor
**Parámetros:** TIP=1, TCP=1, TFP=1
**Algoritmo:** Priority Scheduling (expropiativo por prioridad)
**Política Ready:** Ordenada por prioridad (menor número = mayor prioridad)
**Tie-breaker:** Orden de llegada a READY
**TCP:** L→C (DISPATCH) y **expropiación por prioridad**

**Procesos:**
P1: arribo=0, ráfaga=7, **prioridad=3** (baja)
P2: arribo=1, ráfaga=2, **prioridad=1** (alta - más prioritario)  
P3: arribo=2, ráfaga=5, **prioridad=2** (media)

**CONVENCIÓN:** Menor número = Mayor prioridad
**Orden prioridades:** P2(1) > P3(2) > P1(3)
end note

== Orden de Resolución de Eventos Simultáneos ==
note over Motor
**(1) C→T** (FIN_PROCESO)
**(2) C→B** (FIN_RAFAGA_CPU → I/O)
**(3) C→L** (PREEMPTION por prioridad) - **con TCP**
**(4) B→L** (FIN_IO) + **evaluación expropiación**
**(5) N→L** (FIN_TIP) + **evaluación expropiación**
**(6) L→C** (DISPATCH) - **con TCP**

**CRÍTICO:** Cada N→L y B→L puede causar expropiación
**si prioridad del nuevo > prioridad del actual en CPU**
end note

== Cronología Priority Scheduling ==

group t=0: Arribo P1
    Motor -> P1: ARRIBO
    P1 -> P1: estado = NUEVO, prioridad = 3
    Motor -> Log: registrar(t=0, ARRIBO, P1, ráfaga=7, prioridad=3)
    Motor -> Motor: programar(t=1, FIN_TIP, P1)
end

group t=1: P1 N→L, Arribo P2
    Motor -> P1: FIN_TIP
    P1 -> P1: estado = LISTO, prioridad = 3
    Motor -> RQ: insertar P1 → [P1(prio=3)]
    Motor -> Log: registrar(t=1, FIN_TIP, P1, "NUEVO→LISTO")
    
    Motor -> P2: ARRIBO
    P2 -> P2: estado = NUEVO, prioridad = 1
    Motor -> Log: registrar(t=1, ARRIBO, P2, ráfaga=2, prioridad=1)
    Motor -> Motor: programar(t=2, FIN_TIP, P2)
    
    == Priority Dispatch (solo P1 disponible) ==
    Motor -> RQ: seleccionar mayor prioridad
    Motor -> RQ: remover P1 → [vacía]
    Motor -> CPU: dispatch(P1)
    CPU -> CPU: **cobrar TCP=1**
    Motor -> P1: estado = CORRIENDO, prioridad = 3
    Motor -> Log: registrar(t=1, DISPATCH, P1, "LISTO→CORRIENDO", tcp=1)
    Motor -> Motor: programar(t=9, FIN_RAFAGA_CPU, P1)
    note right: **t=1+1(TCP)+7(ráfaga)=9**
end

group t=2: P2 N→L con EVALUACIÓN PRIORIDAD, Arribo P3
    Motor -> P2: FIN_TIP
    P2 -> P2: estado = LISTO, prioridad = 1
    Motor -> RQ: insertar P2 → [P2(prio=1)]
    Motor -> Log: registrar(t=2, FIN_TIP, P2, "NUEVO→LISTO")
    
    == Priority Evaluación de Expropiación ==
    Motor -> Motor: evaluar expropiación por prioridad
    note right: **P1 en CPU:** prioridad = 3 (baja)\n**P2 nuevo:** prioridad = 1 (alta)\n**1 < 3 → EXPROPIAR P1**
    
    Motor -> CPU: expropiar P1
    CPU -> CPU: **cobrar TCP=1** (expropiación)
    Motor -> P1: estado = LISTO, prioridad = 3
    Motor -> RQ: insertar P1 ordenado → [P2(prio=1), P1(prio=3)]
    Motor -> Log: registrar(t=2, PREEMPTION, P1, "CORRIENDO→LISTO", tcp=1, causa="P2 mayor prioridad")
    
    Motor -> P3: ARRIBO
    P3 -> P3: estado = NUEVO, prioridad = 2
    Motor -> Log: registrar(t=2, ARRIBO, P3, ráfaga=5, prioridad=2)
    Motor -> Motor: programar(t=3, FIN_TIP, P3)
    
    == Priority Dispatch de mayor prioridad ==
    Motor -> RQ: seleccionar mayor prioridad (P2)
    Motor -> RQ: remover P2 → [P1(prio=3)]
    Motor -> CPU: dispatch(P2)
    CPU -> CPU: **cobrar TCP=1**
    Motor -> P2: estado = CORRIENDO, prioridad = 1
    Motor -> Log: registrar(t=2, DISPATCH, P2, "LISTO→CORRIENDO", tcp=1)
    Motor -> Motor: programar(t=5, FIN_RAFAGA_CPU, P2)
    note right: **t=2+1(TCP)+2(ráfaga)=5**
end

group t=3: P3 N→L con EVALUACIÓN PRIORIDAD
    Motor -> P3: FIN_TIP
    P3 -> P3: estado = LISTO, prioridad = 2
    Motor -> RQ: insertar P3 ordenado por prioridad → [P3(prio=2), P1(prio=3)]
    Motor -> Log: registrar(t=3, FIN_TIP, P3, "NUEVO→LISTO")
    
    == Priority Evaluación de Expropiación ==
    Motor -> Motor: evaluar expropiación por prioridad  
    note right: **P2 en CPU:** prioridad = 1 (alta)\n**P3 nuevo:** prioridad = 2 (media)\n**2 > 1 → NO expropiar**
    
    note right: **ReadyQueue ordenada:** [P3(2), P1(3)]
end

group t=5: P2 termina ráfaga completa
    Motor -> P2: FIN_RAFAGA_CPU
    P2 -> P2: estado = TERMINADO
    Motor -> CPU: liberar()
    Motor -> Log: registrar(t=5, FIN_RAFAGA_CPU, P2, "CORRIENDO→TERMINADO")
    Motor -> Motor: programar(t=6, FIN_PROCESO, P2)
    
    == Priority Dispatch de mayor prioridad ==
    Motor -> RQ: seleccionar mayor prioridad
    Motor -> RQ: comparar P3(prio=2) vs P1(prio=3)
    Motor -> RQ: remover P3 → [P1(prio=3)]
    Motor -> CPU: dispatch(P3)
    CPU -> CPU: **cobrar TCP=1**
    Motor -> P3: estado = CORRIENDO, prioridad = 2
    Motor -> Log: registrar(t=5, DISPATCH, P3, "LISTO→CORRIENDO", tcp=1)
    Motor -> Motor: programar(t=11, FIN_RAFAGA_CPU, P3)
    note right: **t=5+1(TCP)+5(ráfaga)=11**
end

group t=6: P2 finalización
    Motor -> P2: FIN_PROCESO
    Motor -> Log: registrar(t=6, FIN_PROCESO, P2, "proceso completado")
end

group t=11: P3 termina ráfaga completa
    Motor -> P3: FIN_RAFAGA_CPU
    P3 -> P3: estado = TERMINADO
    Motor -> CPU: liberar()
    Motor -> Log: registrar(t=11, FIN_RAFAGA_CPU, P3, "CORRIENDO→TERMINADO")
    Motor -> Motor: programar(t=12, FIN_PROCESO, P3)
    
    == Priority Dispatch último proceso ==
    Motor -> RQ: seleccionar mayor prioridad (solo P1)
    Motor -> RQ: remover P1 → [vacía]
    Motor -> CPU: dispatch(P1)
    CPU -> CPU: **cobrar TCP=1**
    Motor -> P1: estado = CORRIENDO, prioridad = 3
    Motor -> Log: registrar(t=11, DISPATCH, P1, "LISTO→CORRIENDO", tcp=1)
    Motor -> Motor: programar(t=17, FIN_RAFAGA_CPU, P1)
    note right: **t=11+1(TCP)+6(ráfaga restante)=18**\n**P1 ejecutó 1 unidad antes (t=1-2)**
end

group t=12: P3 finalización
    Motor -> P3: FIN_PROCESO
    Motor -> Log: registrar(t=12, FIN_PROCESO, P3, "proceso completado")
end

group t=18: P1 termina ráfaga completa
    Motor -> P1: FIN_RAFAGA_CPU
    P1 -> P1: estado = TERMINADO
    Motor -> CPU: liberar()
    Motor -> Log: registrar(t=18, FIN_RAFAGA_CPU, P1, "CORRIENDO→TERMINADO")
    Motor -> Motor: programar(t=19, FIN_PROCESO, P1)
    
    note right: **Simulación completa**\n**ReadyQueue vacía → CPU idle**
end

group t=19: P1 finalización
    Motor -> P1: FIN_PROCESO
    Motor -> Log: registrar(t=19, FIN_PROCESO, P1, "proceso completado")
end

== Casos Especiales Priority Scheduling ==
group Tie-breaker misma prioridad
    note over Motor
    **Ejemplo:** P4 y P5 con prioridad=2
    - P4: llegó a READY en t=5
    - P5: llegó a READY en t=7
    
    **Priority tie-breaker:** P4 seleccionado
    **(llegó antes a READY)**
    **ReadyQueue:** [P4(prio=2, t_ready=5), P5(prio=2, t_ready=7)]
    end note
end

group Aging para evitar starvation
    note over Motor
    **Problema:** Procesos de baja prioridad pueden sufrir starvation
    **Solución:** Aging - incrementar prioridad con el tiempo
    
    **Ejemplo implementación:**
    - Cada X unidades en READY → prioridad--
    - Límite mínimo de prioridad
    - EventLogger registra cambios de prioridad
    end note
end

group Priority Inversion con I/O
    note over Motor
    **Escenario complejo:**
    - P_alto(prio=1) necesita recurso que tiene P_bajo(prio=3)
    - P_medio(prio=2) llega y expropie P_bajo
    - P_alto debe esperar a P_medio → inversión prioridad
    
    **Solución:** Priority inheritance protocol
    end note
end

group Priority con múltiples niveles
    note over Motor
    **Extensión académica:**
    - Prioridades dinámicas vs estáticas
    - Multiple feedback queues
    - Diferentes algoritmos por nivel de prioridad
    - Degradación automática de prioridad
    end note
end

== Análisis Priority vs Otros Algoritmos ==
note over Log
**Orden de ejecución Priority:**
1. P1 (t=1-2): 1 unidad, expropiado por P2  
2. P2 (t=2-5): prioridad=1, más alta
3. P3 (t=5-11): prioridad=2, media
4. P1 (t=11-18): prioridad=3, completar restante

**Tiempo de Espera:**
- P1: (2-1) + (11-2) = 10 (fragmentado por prioridad)
- P2: (2-2) = 0 (ejecutó inmediatamente)
- P3: (5-3) = 2 (esperó a que termine P2)  

**Tiempo Promedio Espera:** (10+0+2)/3 = 4.0

**TCP total = 5** (3 DISPATCH + 1 expropiación)
- Similar a SRTF pero criterio diferente

**Priority:** Garantiza orden de importancia pero
**puede causar starvation en procesos de baja prioridad**

**Comparación:**
- FCFS: 5.33 promedio, sin expropiación
- SJF: 5.33 promedio, sin expropiación  
- SRTF: 4.0 promedio, expropiación por tiempo
- Priority: 4.0 promedio, expropiación por importancia
- RR: depende del quantum, expropiación temporal
end note

@enduml