@startuml
title Diagrama de Secuencia General - Motor de Eventos Discretos (CORREGIDO)
actor Usuario
participant "MotorSimulacion" as Motor
participant "GestionEventos" as Eventos
participant "EstadoSistema" as Estado
participant "Scheduler" as Scheduler
participant "Proceso" as Proc
participant "EventLogger" as Logger
participant "CPU" as CPU

== Configuración y Orden de Prioridades ==
note over Motor
**ORDEN RESOLUCIÓN EVENTOS SIMULTÁNEOS:**
**(1) C→T** (FIN_PROCESO) - máxima prioridad
**(2) C→B** (FIN_RAFAGA_CPU → I/O)
**(3) C→L** (QUANTUM_EXPIRES/expropiación)
**(4) B→L** (FIN_IO) - instantáneo, sin TCP
**(5) N→L** (FIN_TIP) - nuevo ingreso
**(6) L→C** (DISPATCH) - despacho con TCP

**Ejemplo:** Si FIN_RAFAGA_CPU y QUANTUM_EXPIRES coinciden,
primero FIN_RAFAGA_CPU → NO se cobra TCP por expropiación
end note

== Inicialización ==
Usuario -> Motor: ejecutarSimulacion(workload, config)
activate Motor
Motor -> Eventos: inicializar()
Motor -> Estado: inicializar()
Motor -> Logger: configurar()

loop Para cada proceso en workload
    Motor -> Proc: new Proceso(id, arribo, rafaga, prioridad)
    activate Proc
    Motor -> Eventos: programarEvento(arribo, ARRIBO, proceso.id, prioridad=5)
    note right: ARRIBO tiene prioridad 5 (N→L)
    deactivate Proc
end

== Simulación Principal - Motor de Eventos Discretos ==
loop Mientras haya eventos pendientes
    Motor -> Eventos: extraerProximoEvento()
    Eventos --> Motor: evento (ordenado por tiempo, prioridad, secuencia)
    Motor -> Estado: avanzarTiempo(evento.tiempo)
    
    alt Evento: ARRIBO (N→Nuevo, prioridad=5)
        Motor -> Proc: estado = NUEVO
        Motor -> Logger: registrarEvento(ARRIBO, proceso.id, tiempo)
        note right: **Log = fuente de verdad**\nTodo evento mostrado aquí\ndebe estar en el log
        
        alt TIP > 0
            Motor -> Eventos: programarEvento(tiempo+TIP, FIN_TIP, proceso.id, prioridad=5)
            note right: **TIP visible como actividad SO**
        else TIP = 0
            Motor -> Proc: estado = LISTO
            Motor -> Estado: agregarAReadyQueue(proceso)
            Motor -> Motor: evaluarPlanificacion()
        end
        
    else Evento: FIN_TIP (N→L, prioridad=5)
        Motor -> Proc: estado = LISTO
        Motor -> Estado: agregarAReadyQueue(proceso)
        Motor -> Logger: registrarEvento(FIN_TIP, proceso.id, "NUEVO→LISTO")
        Motor -> Motor: evaluarPlanificacion()
        note right: **Tras N→L se evalúa scheduler**
        
    else Evento: DISPATCH (L→C, prioridad=6)
        Motor -> Estado: cpuDisponible?
        alt CPU libre y ReadyQueue no vacía
            Motor -> Scheduler: seleccionarProceso(readyQueue, tiempoActual)
            Scheduler --> Motor: procesoSeleccionado
            note right: **Tie-breakers documentados:**\nFCFS: orden llegada READY\nSJF: próxima ráfaga, luego orden\nSRTF: resto ráfaga actual\nPriority: valor prio, luego orden\nRR: FIFO circular
            
            Motor -> Estado: removerDeReadyQueue(proceso.id)
            Motor -> CPU: dispatch(proceso, tiempo)
            CPU -> CPU: cobrarTCP()
            note right: **TCP SIEMPRE en L→C**
            Motor -> Proc: estado = CORRIENDO
            Motor -> Logger: registrarEvento(DISPATCH, proceso.id, "LISTO→CORRIENDO", tcp=X)
            
            Motor -> Eventos: programarEvento(tiempo+rafagaDuracion, FIN_RAFAGA_CPU, proceso.id, prioridad=2)
            
            alt Algoritmo = RR
                Motor -> Eventos: programarEvento(tiempo+quantum, QUANTUM_EXPIRES, proceso.id, prioridad=3)
                note right: **RR: programa quantum al DISPATCH**
            end
            
        else CPU ocupada o ReadyQueue vacía
            Motor -> CPU: marcarIdle()
            note right: **CPU idle explícito**\nImpacta métricas de utilización
        end
        
    else Evento: FIN_RAFAGA_CPU (C→?, prioridad=2)
        Motor -> Proc: procesarFinRafaga()
        
        alt Proceso completado (todas ráfagas terminadas)
            Motor -> Proc: estado = TERMINADO  
            Motor -> CPU: liberarCPU()
            Motor -> Logger: registrarEvento(FIN_RAFAGA_CPU, proceso.id, "CORRIENDO→TERMINADO")
            
            alt TFP > 0
                Motor -> Eventos: programarEvento(tiempo+TFP, FIN_PROCESO, proceso.id, prioridad=1)
                note right: **TFP visible como actividad SO**
            end
            
        else Proceso necesita I/O  
            Motor -> Proc: estado = BLOQUEADO
            Motor -> CPU: liberarCPU()
            Motor -> Estado: agregarAListaBloqueados(proceso)
            Motor -> Logger: registrarEvento(FIN_RAFAGA_CPU, proceso.id, "CORRIENDO→BLOQUEADO")
            Motor -> Eventos: programarEvento(tiempo+duracionIO, FIN_IO, proceso.id, prioridad=4)
        end
        
        Motor -> Motor: evaluarPlanificacion()
        note right: **Tras liberar CPU, evaluar scheduler**
        
    else Evento: FIN_IO (B→L, prioridad=4)
        Motor -> Estado: removerDeListaBloqueados(proceso.id)
        Motor -> Proc: estado = LISTO
        Motor -> Estado: agregarAReadyQueue(proceso)
        Motor -> Logger: registrarEvento(FIN_IO, proceso.id, "BLOQUEADO→LISTO", tcp=0)
        note right: **B→L instantáneo y sin TCP**
        
        Motor -> Motor: evaluarPlanificacion()
        note right: **Puede causar expropiación inmediata**\n(SRTF/Priority si nuevo < actual)
        
        alt Algoritmo expropiativo (SRTF/Priority)
            Motor -> Scheduler: debeExpropiar(procesoActual, procesoNuevo)
            alt Expropiación requerida
                Motor -> Eventos: programarEvento(tiempo, EXPROPIAR, procesoCPU.id, prioridad=3)
                note right: **Expropiación inmediata en mismo timestamp**
            end
        end
        
    else Evento: QUANTUM_EXPIRES (C→L, prioridad=3)
        alt Proceso aún en CPU
            Motor -> CPU: expropiar(proceso)
            CPU -> CPU: cobrarTCP()
            note right: **TCP por expropiación RR**
            Motor -> Proc: estado = LISTO  
            Motor -> Estado: agregarAlFinalReadyQueue(proceso)
            Motor -> Logger: registrarEvento(QUANTUM_EXPIRES, proceso.id, "CORRIENDO→LISTO", tcp=X)
            
            Motor -> Motor: evaluarPlanificacion()
        else Proceso ya terminó ráfaga
            note right: **Si FIN_RAFAGA_CPU ocurrió primero,**\n**este evento se ignora (no TCP)**
        end
        
    else Evento: EXPROPIAR (C→L, prioridad=3)
        Motor -> CPU: expropiar(procesoActual)
        CPU -> CPU: cobrarTCP()
        Motor -> Proc: estado = LISTO
        Motor -> Estado: insertarEnReadyQueue(procesoActual) 
        Motor -> Logger: registrarEvento(EXPROPIAR, procesoActual.id, "CORRIENDO→LISTO", tcp=X)
        
        Motor -> Motor: evaluarPlanificacion()
        note right: **Inmediatamente intenta despacho del nuevo proceso**
        
    else Evento: FIN_PROCESO (finalización completa, prioridad=1)
        Motor -> Logger: registrarEvento(FIN_PROCESO, proceso.id, "proceso completado")
        note right: **TFP completado**
    end
    
    == Evaluación Continua de Planificación ==
    alt CPU libre y ReadyQueue no vacía
        Motor -> Eventos: programarEvento(tiempo, DISPATCH, null, prioridad=6)
        note right: **Despacho inmediato si CPU disponible**
    end
end

== Resultado Final ==
Motor -> Logger: construirEventLog()
Logger --> Motor: eventosCompletos
Motor -> Motor: calcularMetricas(eventosCompletos)
note over Motor
**El Gantt y las métricas se reconstruyen**
**SOLO desde este log de eventos**
**No hay cálculos paralelos o estimaciones**
end note

Motor --> Usuario: ResultadoSimulacion(eventos, metricas, gantt)
deactivate Motor

== Casos Especiales Mostrados ==
group Llegadas Simultáneas (B→L y N→L al mismo tiempo)
    note over Motor
    **Ejemplo t=5:**
    - FIN_IO(P2): B→L (prioridad 4) 
    - FIN_TIP(P3): N→L (prioridad 5)
    
    **Orden de procesamiento:**
    1. FIN_IO(P2) - reingresa desde I/O
    2. FIN_TIP(P3) - nuevo ingreso
    3. Evaluar planificación con ambos en READY
    end note
end

group Empate FIN_RAFAGA_CPU vs QUANTUM_EXPIRES
    note over Motor
    **Ejemplo t=10, P1 en CPU:**
    - FIN_RAFAGA_CPU(P1) (prioridad 2)
    - QUANTUM_EXPIRES(P1) (prioridad 3)
    
    **Resultado:**
    1. FIN_RAFAGA_CPU procesa primero
    2. P1 → BLOQUEADO o TERMINADO
    3. QUANTUM_EXPIRES se ignora (P1 ya no en CPU)
    4. **NO se cobra TCP por quantum**
    end note
end

@enduml