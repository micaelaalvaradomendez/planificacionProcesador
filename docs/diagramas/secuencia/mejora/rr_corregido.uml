@startuml
title Round Robin (RR) Q=3 - Secuencia Corregida con Quantum y TCP Explícitos
participant "Motor" as Motor
participant "P1" as P1
participant "P2" as P2  
participant "P3" as P3
participant "CPU" as CPU
participant "ReadyQueue" as RQ
participant "Timer" as Timer
participant "EventLogger" as Log

== Configuración Round Robin ==
note over Motor
**Parámetros:** TIP=1, TCP=1, TFP=1, **Quantum=3**
**Algoritmo:** Round Robin (expropiativo por tiempo)
**Política Ready:** FIFO circular 
**Tie-breaker:** Orden de llegada a READY
**TCP:** Solo en L→C (DISPATCH) y C→L (expropiación quantum)

**Procesos:**
P1: arribo=0, ráfaga=7 (supera quantum)
P2: arribo=1, ráfaga=2 (menor que quantum)  
P3: arribo=2, ráfaga=5 (supera quantum)
end note

== Orden de Resolución de Eventos Simultáneos ==
note over Motor
**(1) C→T** (FIN_PROCESO)
**(2) C→B** (FIN_RAFAGA_CPU → I/O)  
**(3) C→L** (QUANTUM_EXPIRES) - **con TCP**
**(4) B→L** (FIN_IO)
**(5) N→L** (FIN_TIP)
**(6) L→C** (DISPATCH) - **con TCP**

**CRÍTICO RR:** Si FIN_RAFAGA_CPU y QUANTUM_EXPIRES 
coinciden, FIN_RAFAGA_CPU tiene prioridad → **NO TCP**
end note

== Cronología Round Robin ==

group t=0: Arribo P1
    Motor -> P1: ARRIBO
    P1 -> P1: estado = NUEVO
    Motor -> Log: registrar(t=0, ARRIBO, P1)
    Motor -> Motor: programar(t=1, FIN_TIP, P1)
end

group t=1: P1 N→L, Arribo P2
    Motor -> P1: FIN_TIP
    P1 -> P1: estado = LISTO
    Motor -> RQ: agregar P1 → [P1]
    Motor -> Log: registrar(t=1, FIN_TIP, P1, "NUEVO→LISTO")
    
    Motor -> P2: ARRIBO
    P2 -> P2: estado = NUEVO  
    Motor -> Log: registrar(t=1, ARRIBO, P2)
    Motor -> Motor: programar(t=2, FIN_TIP, P2)
    
    == RR Dispatch con Quantum ==
    Motor -> RQ: seleccionar próximo (RR-FIFO)
    Motor -> RQ: remover P1 → [vacía]
    Motor -> CPU: dispatch(P1)
    CPU -> CPU: **cobrar TCP=1**
    Motor -> P1: estado = CORRIENDO
    Motor -> Timer: **programar QUANTUM_EXPIRES(t=5)**
    note right: **RR: quantum inicia al DISPATCH**\n**t=1+1(TCP)+3(quantum)=5**
    Motor -> Log: registrar(t=1, DISPATCH, P1, "LISTO→CORRIENDO", tcp=1)
    Motor -> Motor: programar(t=9, FIN_RAFAGA_CPU, P1)
    note right: **ráfaga completa sería t=1+1+7=9**\n**pero quantum expira en t=5**
end

group t=2: P2 N→L, Arribo P3  
    Motor -> P2: FIN_TIP
    P2 -> P2: estado = LISTO
    Motor -> RQ: agregar P2 → [P2]
    Motor -> Log: registrar(t=2, FIN_TIP, P2, "NUEVO→LISTO")
    
    Motor -> P3: ARRIBO
    P3 -> P3: estado = NUEVO
    Motor -> Log: registrar(t=2, ARRIBO, P3)
    Motor -> Motor: programar(t=3, FIN_TIP, P3)
    
    note right: **P1 en CPU, quantum restante=2**
end

group t=3: P3 N→L
    Motor -> P3: FIN_TIP  
    P3 -> P3: estado = LISTO
    Motor -> RQ: agregar P3 → [P2, P3]
    Motor -> Log: registrar(t=3, FIN_TIP, P3, "NUEVO→LISTO")
    
    note right: **P1 en CPU, quantum restante=1**
end

group t=5: QUANTUM EXPIRA P1
    Motor -> Timer: QUANTUM_EXPIRES(P1)
    Timer -> CPU: expropiar P1
    CPU -> CPU: **cobrar TCP=1** (expropiación)
    Motor -> P1: estado = LISTO  
    Motor -> RQ: agregar P1 al FINAL → [P2, P3, P1]
    Motor -> P1: ráfagaRestante = 7-3 = 4
    Motor -> Log: registrar(t=5, QUANTUM_EXPIRES, P1, "CORRIENDO→LISTO", tcp=1)
    
    note right: **RR: proceso expropiado va al FINAL**\n**TCP por expropiación quantum**
    
    == RR Dispatch Siguiente ==
    Motor -> RQ: seleccionar próximo (FIFO)
    Motor -> RQ: remover P2 → [P3, P1]
    Motor -> CPU: dispatch(P2)
    CPU -> CPU: **cobrar TCP=1**
    Motor -> P2: estado = CORRIENDO
    Motor -> Timer: **programar QUANTUM_EXPIRES(t=9)**
    note right: **t=5+1(TCP)+3(quantum)=9**
    Motor -> Log: registrar(t=5, DISPATCH, P2, "LISTO→CORRIENDO", tcp=1)
    Motor -> Motor: programar(t=8, FIN_RAFAGA_CPU, P2)
    note right: **P2 ráfaga=2 < quantum=3**\n**terminará antes del quantum**
end

group t=8: P2 termina ráfaga (ANTES de quantum)
    Motor -> P2: FIN_RAFAGA_CPU
    P2 -> P2: estado = TERMINADO
    Motor -> CPU: liberar()
    Motor -> Timer: **cancelar QUANTUM_EXPIRES(P2)**
    Motor -> Log: registrar(t=8, FIN_RAFAGA_CPU, P2, "CORRIENDO→TERMINADO")
    Motor -> Motor: programar(t=9, FIN_PROCESO, P2)
    
    note right: **CRÍTICO:** P2 termina en t=8\n**QUANTUM_EXPIRES en t=9 se cancela**\n**NO se cobra TCP por quantum**
    
    == RR Dispatch Siguiente ==
    Motor -> RQ: seleccionar próximo (FIFO)
    Motor -> RQ: remover P3 → [P1]
    Motor -> CPU: dispatch(P3)
    CPU -> CPU: **cobrar TCP=1**
    Motor -> P3: estado = CORRIENDO
    Motor -> Timer: **programar QUANTUM_EXPIRES(t=12)**
    Motor -> Log: registrar(t=8, DISPATCH, P3, "LISTO→CORRIENDO", tcp=1)
    Motor -> Motor: programar(t=14, FIN_RAFAGA_CPU, P3)
    note right: **t=8+1(TCP)+5(ráfaga)=14**\n**quantum en t=12 expira antes**
end

group t=9: P2 finalización (evento ya programado)
    Motor -> P2: FIN_PROCESO
    Motor -> Log: registrar(t=9, FIN_PROCESO, P2, "proceso completado")
end

group t=12: QUANTUM EXPIRA P3
    Motor -> Timer: QUANTUM_EXPIRES(P3)
    Timer -> CPU: expropiar P3
    CPU -> CPU: **cobrar TCP=1**
    Motor -> P3: estado = LISTO
    Motor -> RQ: agregar P3 al FINAL → [P1, P3]
    Motor -> P3: ráfagaRestante = 5-3 = 2
    Motor -> Log: registrar(t=12, QUANTUM_EXPIRES, P3, "CORRIENDO→LISTO", tcp=1)
    
    == RR Dispatch P1 (segunda vez) ==
    Motor -> RQ: seleccionar próximo (FIFO)
    Motor -> RQ: remover P1 → [P3]  
    Motor -> CPU: dispatch(P1)
    CPU -> CPU: **cobrar TCP=1**
    Motor -> P1: estado = CORRIENDO
    Motor -> Timer: **programar QUANTUM_EXPIRES(t=16)**
    Motor -> Log: registrar(t=12, DISPATCH, P1, "LISTO→CORRIENDO", tcp=1)
    Motor -> Motor: programar(t=17, FIN_RAFAGA_CPU, P1)
    note right: **P1 ráfagaRestante=4 > quantum=3**\n**expirará quantum en t=16**
end

group t=16: QUANTUM EXPIRA P1 (segunda vez)
    Motor -> Timer: QUANTUM_EXPIRES(P1)
    Timer -> CPU: expropiar P1  
    CPU -> CPU: **cobrar TCP=1**
    Motor -> P1: estado = LISTO
    Motor -> RQ: agregar P1 al FINAL → [P3, P1]
    Motor -> P1: ráfagaRestante = 4-3 = 1
    Motor -> Log: registrar(t=16, QUANTUM_EXPIRES, P1, "CORRIENDO→LISTO", tcp=1)
    
    == RR Dispatch P3 (segunda vez) ==
    Motor -> RQ: seleccionar próximo (FIFO)
    Motor -> RQ: remover P3 → [P1]
    Motor -> CPU: dispatch(P3)
    CPU -> CPU: **cobrar TCP=1**
    Motor -> P3: estado = CORRIENDO
    Motor -> Timer: **programar QUANTUM_EXPIRES(t=20)**
    Motor -> Log: registrar(t=16, DISPATCH, P3, "LISTO→CORRIENDO", tcp=1)
    Motor -> Motor: programar(t=19, FIN_RAFAGA_CPU, P3)
    note right: **P3 ráfagaRestante=2 < quantum=3**
end

group t=19: P3 termina (ANTES de quantum)
    Motor -> P3: FIN_RAFAGA_CPU
    P3 -> P3: estado = TERMINADO
    Motor -> CPU: liberar()
    Motor -> Timer: **cancelar QUANTUM_EXPIRES(P3)**
    Motor -> Log: registrar(t=19, FIN_RAFAGA_CPU, P3, "CORRIENDO→TERMINADO")
    Motor -> Motor: programar(t=20, FIN_PROCESO, P3)
    
    == RR Dispatch P1 (tercera vez) ==
    Motor -> RQ: seleccionar próximo (FIFO)
    Motor -> RQ: remover P1 → [vacía]
    Motor -> CPU: dispatch(P1)
    CPU -> CPU: **cobrar TCP=1**  
    Motor -> P1: estado = CORRIENDO
    Motor -> Timer: **programar QUANTUM_EXPIRES(t=23)**
    Motor -> Log: registrar(t=19, DISPATCH, P1, "LISTO→CORRIENDO", tcp=1)
    Motor -> Motor: programar(t=21, FIN_RAFAGA_CPU, P1)
    note right: **P1 ráfagaRestante=1 < quantum=3**
end

group t=20: P3 finalización
    Motor -> P3: FIN_PROCESO
    Motor -> Log: registrar(t=20, FIN_PROCESO, P3, "proceso completado")
end

group t=21: P1 termina completamente (ANTES de quantum)
    Motor -> P1: FIN_RAFAGA_CPU
    P1 -> P1: estado = TERMINADO
    Motor -> CPU: liberar()
    Motor -> Timer: **cancelar QUANTUM_EXPIRES(P1)**
    Motor -> Log: registrar(t=21, FIN_RAFAGA_CPU, P1, "CORRIENDO→TERMINADO")
    Motor -> Motor: programar(t=22, FIN_PROCESO, P1)
    
    note right: **Simulación completa**\n**ReadyQueue vacía → CPU idle**
end

group t=22: P1 finalización
    Motor -> P1: FIN_PROCESO
    Motor -> Log: registrar(t=22, FIN_PROCESO, P1, "proceso completado")
end

== Casos Especiales Round Robin ==
group Empate FIN_RAFAGA_CPU vs QUANTUM_EXPIRES
    note over Motor
    **Ejemplo crítico (no ocurrió arriba):**
    Si P2 tuviera ráfaga=3 exacta:
    - FIN_RAFAGA_CPU en t=9 (prioridad 2)  
    - QUANTUM_EXPIRES en t=9 (prioridad 3)
    
    **Resultado correcto:**
    1. FIN_RAFAGA_CPU procesa primero
    2. P2 → TERMINADO o BLOQUEADO  
    3. QUANTUM_EXPIRES se ignora
    4. **NO se cobra TCP** por quantum
    end note
end

group RR con I/O (extensión del ejemplo)
    note over Motor
    **Si procesos tuvieran I/O:**
    - C→B: NO cobra TCP (transición natural)
    - B→L: instantáneo, sin TCP
    - Tras B→L: proceso va al FINAL de ReadyQueue
    - NO se reinicia quantum hasta nuevo DISPATCH
    end note
end

== Análisis TCP en Round Robin ==
note over Log
**TCP cobrado en este ejemplo:**
- t=1: DISPATCH P1 → tcp=1
- t=5: QUANTUM_EXPIRES P1 → tcp=1 (expropiación)
- t=5: DISPATCH P2 → tcp=1  
- t=8: DISPATCH P3 → tcp=1 (NO tcp en t=8 por fin natural P2)
- t=12: QUANTUM_EXPIRES P3 → tcp=1 (expropiación)
- t=12: DISPATCH P1 → tcp=1
- t=16: QUANTUM_EXPIRES P1 → tcp=1 (expropiación)  
- t=16: DISPATCH P3 → tcp=1
- t=19: DISPATCH P1 → tcp=1 (NO tcp en t=19 por fin natural P3)

**Total TCP = 9** (vs algoritmos no expropiativos ≈ 3)

**El EventLogger registra exactamente cuándo y por qué**
**se cobra cada TCP → métricas precisas**
end note

@enduml