@startuml
title Sistema I/O Mejorado - Con Estados Suspendidos
participant "AdaptadorSimuladorDominio" as Adaptador
participant "MotorSimulacion" as Motor  
participant "EstadoSistema" as Estado
participant "EventQueue" as EQ
participant "ReadyQ" as RQ
participant "BlockedQ" as BQ
participant "Logger" as Logger
participant "CPU" as CPU
participant "IODevice" as IO
participant "EstrategiaScheduler" as Strategy
participant "Proceso" as P

== Bucle Principal I/O ==

note top of Motor: **Orden eventos simultáneos:**\n1.FIN_PROCESO 2.FIN_RAFAGA_CPU 3.EXPROPIACION\n4.FIN_IO 5.FIN_TIP 6.DISPATCH

loop while EventQueue not empty
    Motor -> EQ: popNext() [orden prioridad académica]
    EQ --> Motor: evento
    Motor -> Logger: registrar(t, tipo, pid, descripcion)

group Inicio de Operación I/O (FIN_RAFAGA_CPU prioridad 2)
    Motor -> P: completarRafaga()
    
    alt [necesita I/O] proceso requiere operación de entrada/salida
        Motor -> P: estado = CORRIENDO → BLOQUEADO
        Motor -> CPU: liberar()
        Motor -> Logger: registrar(t, "C->B", pid, "inicia I/O")
        
        note right: **Transición C→B:**\nINSTANTÁNEA (Δt=0)\nNO se cobra TCP
        
        Motor -> Estado: verificarMemoriaDisponible()
        alt [memoria suficiente]
            Motor -> BQ: push(P, ioSpec)
            Motor -> EQ: schedule(FIN_IO, t+duracionIO, pid) [prioridad 4]
            P -> IO: iniciarOperacion(duracion)
            Motor -> Logger: registrar(t, "IO_START", pid, "I/O normal")
        else [presión de memoria]
            Motor -> P: estado = BLOQUEADO → BLOQUEADO_SUSPENDIDO
            Motor -> Estado: liberarMemoria(P.tamaño)
            Motor -> Estado: suspenderProceso(P)
            Motor -> EQ: schedule(FIN_IO, t+duracionIO, pid) [prioridad 4]
            P -> IO: iniciarOperacion(duracion) [en segundo plano]
            Motor -> Logger: registrar(t, "IO_SUSPEND", pid, "I/O suspendido")
            Motor -> Motor: activarProcesosSuspendidos()
        end
        
        Motor -> Estado: procesoEnCPU = null
        Motor -> CPU: idle()
    else [terminó] todas las ráfagas completadas
        Motor -> EQ: schedule(FIN_PROCESO, t, pid) [prioridad 1]
    end
end

group Finalización I/O (FIN_IO prioridad 4)
    Motor -> IO: completarOperacion(pid)
    IO --> Motor: operación completada
    
    alt [proceso normal] en memoria
        Motor -> BQ: remove(pid)
        Motor -> P: estado = BLOQUEADO → LISTO
        Motor -> RQ: push(P, criterio_politica)
        Motor -> Logger: registrar(t, "B->L", pid, "I/O completado")
        note right: **B→L costo 0** - transición instantánea
    else [proceso suspendido] fuera de memoria
        Motor -> P: estado = BLOQUEADO_SUSPENDIDO → LISTO_SUSPENDIDO
        Motor -> Estado: mantenerSuspendido(P) [sin memoria aún]
        Motor -> Logger: registrar(t, "BS->LS", pid, "I/O completado suspendido")
        
        Motor -> Estado: verificarMemoriaDisponible()
        alt [hay memoria suficiente]
            Motor -> P: estado = LISTO_SUSPENDIDO → LISTO
            Motor -> Estado: reservarMemoria(P.tamaño)
            Motor -> RQ: push(P, criterio_politica)
            Motor -> Logger: registrar(t, "LS->L", pid, "reactivado tras I/O")
        end
    end
end

group Despacho tras I/O
    Motor -> Motor: evaluarPlanificacion()
    
    alt [CPU idle y RQ no vacía]
        Motor -> EQ: schedule(DISPATCH, t, "") [prioridad 6]
    else [CPU ocupada] evaluar expropiación por política
        Motor -> Strategy: evaluarExpropiacion(proceso_io, proceso_cpu)
        Strategy --> Motor: decision_expropiacion
        
        alt [expropiación requerida] por política específica
            Motor -> EQ: schedule(EXPROPIACION, t, proceso_cpu) [prioridad 3]
            Motor -> Logger: registrar(t, "PREEMPT_IO", proceso_cpu, "expropiado por FIN_IO")
        end
    end
end

group Procesamiento DISPATCH (prioridad 6)
    alt [CPU libre y RQ no vacía]
        Motor -> RQ: verificarProcesosLISTOS() [no suspendidos]
        RQ --> Motor: lista_disponibles
        
        alt [hay procesos LISTO disponibles]
            Motor -> Strategy: elegirSiguiente(lista_disponibles, t)
            Strategy --> Motor: P_next
            Motor -> RQ: remove(P_next)
            ref over Motor, CPU : aplicarTCP()\nLISTO -> CORRIENDO (t += TCP)
            Motor -> P_next: estado = LISTO → CORRIENDO
            Motor -> CPU: asignar(P_next)
            Motor -> Estado: procesoEnCPU = P_next
            Motor -> EQ: schedule(FIN_RAFAGA_CPU, t+TCP+duracion, P_next) [prioridad 2]
            Motor -> Logger: registrar(t, "L->C", P_next, "dispatch + TCP")
        else [solo procesos suspendidos]
            Motor -> CPU: mantenerIdle()
            Motor -> Estado: intentarReactivarSuspendidos()
            Motor -> Logger: registrar(t, "CPU_IDLE", "", "solo procesos suspendidos")
        end
    else [RQ vacía]
        Motor -> CPU: mantenerIdle()
        Motor -> Logger: registrar(t, "CPU_IDLE", "", "no hay procesos listos")
    end
end

group Gestión de Memoria y Estados Suspendidos
    Motor -> Estado: gestionarMemoria()
    
    alt [presión de memoria] memoria < umbralSuspension
        Motor -> Estado: suspenderProcesosPorMemoria()
        
        loop para cada proceso candidato a suspensión
            Motor -> Estado: seleccionarParaSuspension() [mayor tamaño, menor prioridad]
            
            alt [proceso en estado LISTO]
                Motor -> P: estado = LISTO → LISTO_SUSPENDIDO
                Motor -> RQ: remove(P)
                Motor -> Estado: liberarMemoria(P.tamaño)
                Motor -> Logger: registrar(t, "L->LS", P, "suspendido por memoria")
            else [proceso en estado BLOQUEADO]
                Motor -> P: estado = BLOQUEADO → BLOQUEADO_SUSPENDIDO
                Motor -> BQ: mantener(P) [I/O continúa]
                Motor -> Estado: liberarMemoria(P.tamaño)
                Motor -> Logger: registrar(t, "B->BS", P, "suspendido por memoria")
            end
        end
    else [memoria disponible] memoria >= umbralActivacion
        Motor -> Estado: reactivarProcesosSuspendidos()
        
        loop para cada proceso suspendido que quepa
            Motor -> Estado: seleccionarParaReactivacion() [FIFO, tamaño disponible]
            
            alt [proceso LISTO_SUSPENDIDO]
                Motor -> P: estado = LISTO_SUSPENDIDO → LISTO
                Motor -> Estado: reservarMemoria(P.tamaño)
                Motor -> RQ: push(P, criterio_politica)
                Motor -> Logger: registrar(t, "LS->L", P, "reactivado")
            else [proceso BLOQUEADO_SUSPENDIDO]
                Motor -> P: estado = BLOQUEADO_SUSPENDIDO → BLOQUEADO
                Motor -> Estado: reservarMemoria(P.tamaño)
                Motor -> BQ: restore(P) [I/O ya en progreso]
                Motor -> Logger: registrar(t, "BS->B", P, "reactivado")
            end
        end
    end
end

== Métricas y Logger ==
note over Logger: **Logger registra todos los eventos I/O:**\n• Inicio/fin de operaciones I/O\n• Transiciones de suspensión\n• Tiempos de bloqueo\n• Overlapping I/O y CPU\n**Para reconstruir:**\n• Utilización de dispositivos I/O\n• Tiempos de espera por I/O\n• Eficiencia de gestión de memoria

end
        note right: **CPU idle** + intentar activar suspendidos
    end
end

group Finalización I/O (EventoMejorado prioridad 4)
    Motor -> Evento: procesar FIN_IO (BLOQUEADO_A_LISTO)
    IO -> Motor: operación I/O completa
    
    alt Proceso en estado BLOQUEADO
        Motor -> P: estado = BLOQUEADO → LISTO
        Motor -> Estado: verificar memoria suficiente
        alt Hay memoria
            Motor -> ReadyQ: insertar proceso en cola LISTO
            Motor -> Strategy: alVolverseListoProceso(P, tiempoActual)
        else Sin memoria
            Motor -> P: estado = LISTO → LISTO_SUSPENDIDO
            note right: **Suspensión inmediata** por falta de memoria
        end
    else Proceso en BLOQUEADO_SUSPENDIDO
        Motor -> Estado: verificar memoria suficiente
        alt Hay memoria
            Motor -> P: estado = BLOQUEADO_SUSPENDIDO → BLOQUEADO
            Motor -> Estado: reservar memoria para P
            Motor -> Evento: continuar operación I/O si necesario
        else Sin memoria
            note right: Permanece BLOQUEADO_SUSPENDIDO
        end
    end
    
    note right: **Transición B→L:** INSTANTÁNEA (Δt=0), NO TCP
    
    alt Scheduling Expropiativo (Priority, SRTF)
        Motor -> Strategy: debeExpropiar(procesoActual, P, tiempo)
        alt Debe expropiar
            Motor -> Evento: programar EXPROPIACION(tiempo, prioridad 3)
            note right: **TCP pendiente** para próximo DISPATCH
        else Mantener proceso actual
            note right: P espera en Ready Queue
        end
    else Scheduling No Expropiativo (FCFS, SJF)
        note right: P espera su turno, no evalúa expropiación
    else Round Robin
        note right: **Consigna TP:** RR no interrumpe por retorno I/O
    end
end

== Casos Especiales I/O ==

group Múltiples Procesos I/O Simultáneos
    note over IO: **Modelo I/O Paralelo:**
    note over IO: Cada proceso maneja su I/O independiente
    note over IO: No hay cola de espera I/O explícita
    note over IO: Finalizaciones simultáneas posibles
    
    P -> IO: P1 inicia I/O(t=5, dur=3) → fin t=8
    P -> IO: P2 inicia I/O(t=6, dur=2) → fin t=8  
    P -> IO: P3 inicia I/O(t=7, dur=1) → fin t=8
    
    note right: t=8: Tres procesos retornan simultáneamente
    note right: Scheduler maneja orden de reinserción
end

group Validaciones Estado I/O  
    alt Estado Inválido
        P -> P: intento LISTO → BLOQUEADO (sin CPU)
        Sim -> Sim: **ERROR:** Transición inválida
        note right: Solo CORRIENDO → BLOQUEADO válido
    end
    
    alt I/O Doble
        P -> P: estado = BLOQUEADO  
        P -> IO: intento segunda operación I/O
        Sim -> Sim: **ERROR:** Proceso ya en I/O
        note right: Un proceso, una operación I/O activa
    end
    
    alt Duración I/O Inválida
        P -> IO: duración_io ≤ 0
        Sim -> Sim: **ERROR:** I/O instantáneo inválido
        note right: I/O siempre debe tener duración > 0
    end
end

== Métricas I/O ==

group Estadísticas Sistema
    note over Sim: **Métricas I/O Tracking:**
    Sim -> Sim: total_io_operations++
    Sim -> Sim: total_io_time += duración
    Sim -> Sim: io_waiting_time[proceso] += tiempo_espera
    Sim -> Sim: io_utilization = tiempo_io_activo / tiempo_total
    
    note right: **Impacto Performance:**
    note right: I/O reduce CPU utilization
    note right: Aumenta multiprogramming degree  
    note right: Critical para throughput sistema
end

@enduml