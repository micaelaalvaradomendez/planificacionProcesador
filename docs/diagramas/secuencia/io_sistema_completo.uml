@startuml
title Sistema I/O - Gestión de Estados y Transiciones
participant "Simulador" as Sim  
participant "Proceso" as P
participant "CPU" as CPU
participant "ReadyQueue" as RQ
participant "IODevice" as IO
participant "EventQueue" as EQ
participant "Scheduler" as Sch

== Flujo Completo I/O ==

group Inicio de Operación I/O
    P -> CPU: ejecutando ráfaga CPU
    CPU -> P: fin ráfaga CPU
    P -> P: estado = CORRIENDO → BLOQUEADO
    
    note right: **Transición Crítica B→L:** 
    note right: DEBE ser instantánea (0u)
    note right: NO se cobra TCP aquí
    
    Sim -> EQ: registrar evento FIN_IO
    EQ -> EQ: tiempo = actual + duracion_io
    P -> IO: iniciar operación I/O
    IO -> IO: dispositivo ocupado por duración
end

group CPU queda libre - Despacho
    Sim -> RQ: solicitar próximo proceso  
    RQ -> Sch: aplicar política scheduling
    Sch -> RQ: seleccionar proceso P_next
    
    alt Si hay proceso disponible
        RQ -> CPU: despachar P_next
        CPU -> P: estado = LISTO → CORRIENDO  
        Sim -> Sim: **TCP = valor configurado**
        note right: TCP SOLO en L→C (despacho)
    else Ready Queue vacía
        CPU -> CPU: idle hasta próximo evento
        note right: CPU idle, no hay TCP
    end
end

group Finalización I/O
    IO -> IO: operación I/O completa
    IO -> EQ: evento FIN_IO disparado
    EQ -> Sim: procesar evento FIN_IO
    
    Sim -> P: estado = BLOQUEADO → LISTO
    note right: **L instantáneo:** NO hay TCP en B→L
    
    Sim -> RQ: insertar proceso en cola
    RQ -> Sch: evaluar si requiere expropiación
    
    alt Scheduling Preemptive (Priority, SRTF)
        Sch -> CPU: comparar prioridades/tiempos
        alt P_nuevo tiene mayor prioridad
            CPU -> CPU: expropiación del proceso actual
            CPU -> P: estado = CORRIENDO → LISTO  
            Sim -> Sim: **TCP por expropiación**
            RQ -> CPU: despachar P_nuevo
            CPU -> P: estado = LISTO → CORRIENDO
        else Proceso actual mantiene CPU
            RQ -> RQ: P_nuevo espera en cola
        end
    else Scheduling Non-Preemptive (FCFS, SJF, RR)
        RQ -> RQ: P_nuevo espera su turno
        note right: No expropiación por retorno I/O
    end
end

== Casos Especiales I/O ==

group Múltiples Procesos I/O Simultáneos
    note over IO: **Modelo I/O Paralelo:**
    note over IO: Cada proceso maneja su I/O independiente
    note over IO: No hay cola de espera I/O explícita
    note over IO: Finalizaciones simultáneas posibles
    
    P -> IO: P1 inicia I/O(t=5, dur=3) → fin t=8
    P -> IO: P2 inicia I/O(t=6, dur=2) → fin t=8  
    P -> IO: P3 inicia I/O(t=7, dur=1) → fin t=8
    
    note right: t=8: Tres procesos retornan simultáneamente
    note right: Scheduler maneja orden de reinserción
end

group Validaciones Estado I/O  
    alt Estado Inválido
        P -> P: intento LISTO → BLOQUEADO (sin CPU)
        Sim -> Sim: **ERROR:** Transición inválida
        note right: Solo CORRIENDO → BLOQUEADO válido
    end
    
    alt I/O Doble
        P -> P: estado = BLOQUEADO  
        P -> IO: intento segunda operación I/O
        Sim -> Sim: **ERROR:** Proceso ya en I/O
        note right: Un proceso, una operación I/O activa
    end
    
    alt Duración I/O Inválida
        P -> IO: duración_io ≤ 0
        Sim -> Sim: **ERROR:** I/O instantáneo inválido
        note right: I/O siempre debe tener duración > 0
    end
end

== Métricas I/O ==

group Estadísticas Sistema
    note over Sim: **Métricas I/O Tracking:**
    Sim -> Sim: total_io_operations++
    Sim -> Sim: total_io_time += duración
    Sim -> Sim: io_waiting_time[proceso] += tiempo_espera
    Sim -> Sim: io_utilization = tiempo_io_activo / tiempo_total
    
    note right: **Impacto Performance:**
    note right: I/O reduce CPU utilization
    note right: Aumenta multiprogramming degree  
    note right: Critical para throughput sistema
end

@enduml