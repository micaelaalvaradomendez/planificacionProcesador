@startuml
title Diagrama de Secuencia - Motor Simulación ACTUAL (Real Implementation)
actor Usuario
participant "AdaptadorSimuladorDominio" as Adaptador
participant "MotorSimulacionCompleto" as Motor
participant "EstrategiaScheduler" as Scheduler
participant "EstadoSistema" as Estado
participant "EventQueue" as EQ
participant "ReadyQueue" as RQ
participant "BlockedQueue" as BQ
participant "Logger" as Logger
participant "CPU" as CPU

== Inicialización Real ==
Usuario -> Adaptador: ejecutarSimulacion(config)
activate Adaptador
Adaptador -> Scheduler: FactoriaEstrategias.crear(algoritmo)
activate Scheduler
Adaptador -> Motor: new MotorSimulacionCompleto(parametros, estrategia)
activate Motor
Motor -> Estado: inicializar estado sistema
activate Estado
note over Estado: memoriaDisponible=1000MB\numbralSuspension=100MB\ncpuActiva=false
Motor -> EQ: new PriorityQueue<EventoMejorado>()
activate EQ
Motor -> RQ: readyQueue = []
activate RQ
Motor -> BQ: blockedQueue = []
activate BQ
Motor -> Logger: logger = []
activate Logger
Motor -> CPU: estadoSistema.cpuActiva = false
activate CPU

loop Para cada proceso en config.procesos
    Adaptador -> Motor: agregarProceso(proceso)
    Motor -> EQ: enqueue(JOB_LLEGA, arribo, pid) [EventoMejorado con prioridad 0]
    Motor -> Logger: log('SCHEDULE', pid, 'Evento JOB_LLEGA programado')
end

== Simulación Principal REAL ==
note top of Motor: **COMPORTAMIENTO ACTUAL DEL CÓDIGO:**\n**Orden prioridad EventoMejorado:** 0-JOB_LLEGA, 1-FIN_PROCESO, 2-FIN_RAFAGA_CPU,\n3-EXPROPIACION, 4-FIN_IO, 5-FIN_TIP, 6-DISPATCH\n**PROBLEMA:** TIP=0 en tests → transiciones instantáneas

Adaptador -> Motor: ejecutarSimulacion()
Motor -> Logger: log('START', 'SISTEMA', 'Iniciando simulación principal')

loop while !colaEventos.isEmpty()
    Motor -> EQ: dequeue() [EventoMejorado ordenado por prioridad]
    EQ --> Motor: evento
    Motor -> Motor: avanzarTiempo(evento.tiempo)
    Motor -> Motor: procesarEvento(evento)
    
    alt Evento: JOB_LLEGA (Prioridad 0)
        Motor -> Logger: log('EVENT', pid, 'JOB_LLEGA procesado')
        Motor -> Estado: verificar memoria disponible
        alt TIP > 0 (parámetros normales)
            Motor -> EQ: enqueue(FIN_TIP, t+TIP, pid) [prioridad 5]
            Motor -> Logger: log('COST', pid, 'TIP aplicado')
        else TIP = 0 (caso actual tests)
            note right: **COMPORTAMIENTO ACTUAL:**\nTIP=0 hace transición instantánea N→L
            Motor -> Estado: proceso.estado = LISTO
            Motor -> RQ: push(proceso)
            Motor -> Logger: log('TRANSITION', pid, 'N->L instantáneo')
            Motor -> Motor: evaluarPlanificacion() → auto-dispatch
        end
        
    else Evento: FIN_TIP (Prioridad 5)
        note right: **Solo ocurre si TIP > 0**
        Motor -> Estado: verificar memoria disponible
        alt Hay memoria suficiente
            Motor -> Estado: proceso.estado = LISTO
            Motor -> Estado: memoriaDisponible -= proceso.tamaño
            Motor -> RQ: push(proceso)
            Motor -> Logger: log('TRANSITION', pid, 'N->L')
        else Sin memoria (estados suspendidos)
            Motor -> Estado: proceso.estado = LISTO_SUSPENDIDO
            Motor -> RQ: readySuspendedQueue.push(proceso)
            Motor -> Logger: log('TRANSITION', pid, 'N->LS')
        end
        
    else Evento: FIN_PROCESO (Prioridad 1)
        Motor -> Estado: transicion CORRIENDO → TERMINADO
        Motor -> CPU: liberar()
        ref over Motor, Estado : aplicarTFP(proceso)\nCORRIENDO -> TERMINADO
        Motor -> Logger: registrar(t, "C->T", pid, "proceso terminado")
        
    else Evento: FIN_RAFAGA_CPU (Prioridad 2)
        alt [terminó ráfaga] proceso completo
            Motor -> EQ: schedule(FIN_PROCESO, t, pid) [prioridad 1]
        else [necesita I/O] más ráfagas pendientes
            Motor -> Estado: transicion CORRIENDO → BLOQUEADO
            Motor -> BQ: push(pid, ioSpec)
            Motor -> CPU: liberar()
            Motor -> EQ: schedule(FIN_IO, t+duracionIO, pid) [prioridad 4]
            Motor -> Logger: registrar(t, "C->B", pid, "inicia I/O")
        end
        
    else Evento: EXPROPIACION/QUANTUM_EXPIRES (Prioridad 3)
        Motor -> Estado: transicion CORRIENDO → LISTO
        Motor -> CPU: liberar()
        Motor -> RQ: pushTail(pid) [final de cola para RR]
        Motor -> Logger: registrar(t, "C->L", pid, "expropiado")
        
    else Evento: FIN_IO (Prioridad 4)
        Motor -> BQ: remove(pid)
        Motor -> Estado: transicion BLOQUEADO → LISTO
        Motor -> RQ: push(pid, criterio_politica)
        Motor -> Logger: registrar(t, "B->L", pid, "I/O completado")
        note right: **B→L costo 0** (transición instantánea)
        
    else Evento: DISPATCH (Prioridad 6)
        alt [CPU libre y RQ no vacía]
            Motor -> RQ: isEmpty()
            RQ --> Motor: false
            Motor -> Scheduler: elegirSiguiente(readyQueue, t)
            Scheduler --> Motor: procesoSeleccionado
            Motor -> RQ: remove(procesoSeleccionado)
            ref over Motor, CPU : aplicarTCP()\nLISTO -> CORRIENDO
            Motor -> Estado: transicion LISTO → CORRIENDO
            Motor -> CPU: asignar(procesoSeleccionado)
            Motor -> EQ: schedule(FIN_RAFAGA_CPU, t+TCP+duracion, pid) [prioridad 2]
            Motor -> Logger: registrar(t, "L->C", pid, "dispatch+TCP")
            
            opt [algoritmo RR]
                Motor -> EQ: schedule(QUANTUM_EXPIRES, t+TCP+quantum, pid) [prioridad 3]
                note right: Crear timer quantum
            end
        else [CPU libre pero RQ vacía]
            Motor -> CPU: idle()
            Motor -> Logger: registrar(t, "CPU_IDLE", "", "sin procesos listos")
        end
    end
    
    Motor -> Motor: evaluarPlanificacion()
    note right: Después de cada evento,\nevaluar si hay dispatch pendiente
    
    opt [CPU idle y RQ tiene procesos]
        Motor -> EQ: schedule(DISPATCH, t, "") [prioridad 6]
        note right: Auto-programar dispatch inmediato
    end
end
            Sim -> Sim: removerProcesoDeCpu()
            Sim -> Sim: agregarAReadyQueue(proceso)  
            Sim -> Eventos: registrar('AgotamientoQuantum', proceso.id)
            Sim -> Sim: marcarTCPPendiente()
        end
        
    else Evento: PROCESO_TERMINA (Fin TFP)
        Sim -> Eventos: registrar('FinTFP', proceso.id)
    end
    
    alt CPU libre y hay procesos en READY
        Sim -> Scheduler: elegirSiguiente(readyQueue)
        note right: Intento de nuevo despacho
    end
end

== Gestión de Estados Suspendidos ==
group Gestión de Memoria
    Motor -> Estado: verificarMemoriaDisponible()
    alt [memoria < umbralSuspension]
        Motor -> Estado: suspenderProcesosPorMemoria()
        loop para cada proceso en RQ/BQ con mayor tamaño
            Motor -> Estado: transicion LISTO → LISTO_SUSPENDIDO
            Motor -> Estado: transicion BLOQUEADO → BLOQUEADO_SUSPENDIDO  
            Motor -> Estado: liberarMemoria(proceso.tamaño)
            Motor -> Logger: registrar(t, "SUSPEND", pid, "presión memoria")
        end
    else [memoria disponible suficiente]
        Motor -> Estado: reactivarProcesosSuspendidos()
        loop para cada proceso suspendido que quepa
            Motor -> Estado: transicion LISTO_SUSPENDIDO → LISTO
            Motor -> Estado: transicion BLOQUEADO_SUSPENDIDO → BLOQUEADO
            Motor -> Estado: reservarMemoria(proceso.tamaño)
            Motor -> Logger: registrar(t, "REACTIVATE", pid, "memoria disponible")
        end
    end
end

== Finalización y Métricas ==
Motor -> EQ: isEmpty()
EQ --> Motor: true [simulación completa]

Motor -> Logger: generarGantt()
Logger --> Motor: diagramaGantt
note over Logger: **Logger reconstruye métricas:**\n• Tiempos de respuesta\n• Throughput\n• Tiempos de espera\n• Utilización CPU\n**desde eventos registrados**

Motor -> Estado: estadisticasFinales()
Estado --> Motor: metricas
Adaptador -> Usuario: ResultadoSimulacion(gantt, metricas)

deactivate CPU
deactivate Logger
deactivate BQ
deactivate RQ
deactivate EQ
deactivate Estado
deactivate Scheduler
deactivate Motor
deactivate Adaptador

@enduml

' ====================================================================
' DIAGRAMA ESPECÍFICO PARA FCFS (First Come, First Served)
' ====================================================================

@startuml
title Secuencia FCFS - First Come, First Served
participant "Simulador" as Sim
participant "EstrategiaFCFS" as FCFS
participant "ReadyQueue" as RQ
participant "P1" as P1
participant "P2" as P2
participant "P3" as P3

== Ejemplo: P1(arribo=0, CPU=5), P2(arribo=1, CPU=3), P3(arribo=2, CPU=4) ==

note over Sim: t=0 - Arribo P1
Sim -> P1: estado = LISTO
Sim -> RQ: [P1]

note over Sim: t=1 - Arribo P2, pero P1 puede ejecutar
Sim -> P2: estado = LISTO  
Sim -> RQ: [P1, P2]
Sim -> FCFS: elegirSiguiente([P1, P2])
FCFS --> Sim: P1 (primero en cola FIFO)
Sim -> P1: estado = CORRIENDO (t=1)

note over Sim: t=2 - Arribo P3, P1 sigue ejecutando
Sim -> P3: estado = LISTO
Sim -> RQ: [P2, P3] (P1 ya en CPU)

note over Sim: t=6 - P1 termina su ejecución
Sim -> P1: estado = TERMINADO
Sim -> FCFS: elegirSiguiente([P2, P3])
FCFS --> Sim: P2 (siguiente en orden FIFO)
Sim -> P2: estado = CORRIENDO (t=6)

note over Sim: t=9 - P2 termina su ejecución  
Sim -> P2: estado = TERMINADO
Sim -> FCFS: elegirSiguiente([P3])
FCFS --> Sim: P3 (último en cola)
Sim -> P3: estado = CORRIENDO (t=9)

note over Sim: t=13 - P3 termina, simulación completa
Sim -> P3: estado = TERMINADO

note right of FCFS
**Características FCFS:**
- No expropiativo
- Orden FIFO estricto
- Puede causar efecto convoy
- Simple pero no optimal
end note

@enduml

' ====================================================================
' DIAGRAMA ESPECÍFICO PARA ROUND ROBIN (RR)
' ====================================================================

@startuml
title Secuencia Round Robin - Quantum=2
participant "Simulador" as Sim
participant "EstrategiaRR" as RR
participant "ReadyQueue" as RQ
participant "Timer" as Timer
participant "P1" as P1
participant "P2" as P2
participant "P3" as P3

== Ejemplo: P1(CPU=5), P2(CPU=3), P3(CPU=4), Quantum=2 ==

note over Sim: t=0 - Todos los procesos listos
Sim -> RQ: [P1, P2, P3]

Sim -> RR: elegirSiguiente([P1, P2, P3])
RR --> Sim: P1 (primero en cola circular)
Sim -> P1: estado = CORRIENDO
Sim -> Timer: programarQuantumExpire(t=2)

note over Sim: t=2 - Expira quantum de P1
Timer -> Sim: QUANTUM_EXPIRES
Sim -> P1: expropiar(), estado = LISTO
Sim -> RQ: [P2, P3, P1] (P1 va al final)

Sim -> RR: elegirSiguiente([P2, P3, P1])
RR --> Sim: P2 (siguiente en rotación)
Sim -> P2: estado = CORRIENDO  
Sim -> Timer: programarQuantumExpire(t=4)

note over Sim: t=4 - Expira quantum de P2
Timer -> Sim: QUANTUM_EXPIRES
Sim -> P2: expropiar(), estado = LISTO
Sim -> RQ: [P3, P1, P2] (P2 va al final)

Sim -> RR: elegirSiguiente([P3, P1, P2])
RR --> Sim: P3 (siguiente en rotación)
Sim -> P3: estado = CORRIENDO
Sim -> Timer: programarQuantumExpire(t=6)

note over Sim: t=6 - Expira quantum de P3
Timer -> Sim: QUANTUM_EXPIRES
Sim -> P3: expropiar(), estado = LISTO
Sim -> RQ: [P1, P2, P3] (P3 va al final, rotación completa)

note over RR: Continúa rotación hasta que todos terminen...

note right of RR
**Características RR:**
- Expropiativo por tiempo
- Reparto equitativo de CPU
- Cola circular (FIFO rotativo)
- Quantum determina overhead
- Ideal para interactividad
end note

@enduml

' ====================================================================
' DIAGRAMA ESPECÍFICO PARA PRIORITY SCHEDULING
' ====================================================================

@startuml
title Secuencia Priority Scheduling - Expropiativo
participant "Simulador" as Sim
participant "EstrategiaPriority" as Priority
participant "ReadyQueue" as RQ
participant "P1_Prio2" as P1
participant "P2_Prio1" as P2  
participant "P3_Prio3" as P3

== Ejemplo: P1(prio=2, CPU=5), P2(prio=1, CPU=3), P3(prio=3, CPU=4) ==
== Mayor número = Mayor prioridad ==

note over Sim: t=0 - Arribo P1 (prioridad=2)
Sim -> P1: estado = LISTO
Sim -> RQ: [P1]
Sim -> Priority: elegirSiguiente([P1])
Priority --> Sim: P1 (única opción)
Sim -> P1: estado = CORRIENDO

note over Sim: t=1 - Arribo P2 (prioridad=1, menor que P1)
Sim -> P2: estado = LISTO
Sim -> RQ: [P1_CPU, P2] (P1 sigue en CPU)
note right: P2 no expropía (prioridad menor)

note over Sim: t=2 - Arribo P3 (prioridad=3, MAYOR que P1)
Sim -> P3: estado = LISTO
Sim -> Priority: verificarExpropiacion(P1_prio2, P3_prio3)
Priority --> Sim: EXPROPIACION_REQUERIDA

Sim -> P1: expropiar(), estado = LISTO
Sim -> RQ: [P2, P1, P3]
Sim -> Priority: elegirSiguiente([P2, P1, P3])
Priority -> Priority: ordenarPorPrioridad()
Priority --> Sim: P3 (prioridad=3, más alta)
Sim -> P3: estado = CORRIENDO

note over Sim: t=6 - P3 termina (CPU=4)
Sim -> P3: estado = TERMINADO
Sim -> Priority: elegirSiguiente([P2, P1])
Priority --> Sim: P1 (prioridad=2 > prioridad=1)
Sim -> P1: estado = CORRIENDO (retoma ejecución)

note over Sim: t=9 - P1 termina su tiempo restante
Sim -> P1: estado = TERMINADO
Sim -> Priority: elegirSiguiente([P2])
Priority --> Sim: P2 (único restante)
Sim -> P2: estado = CORRIENDO

note over Sim: t=12 - P2 termina
Sim -> P2: estado = TERMINADO

note right of Priority
**Características Priority:**
- Expropiativo por prioridad
- Mayor número = mayor prioridad
- Reordena cola por prioridad
- Puede causar inanición (starvation)
- Respuesta rápida para alta prioridad
end note

@enduml

' ====================================================================
' DIAGRAMA ESPECÍFICO PARA SJF (Shortest Job First)
' ====================================================================

@startuml  
title Secuencia SJF - Shortest Job First (No Expropiativo)
participant "Simulador" as Sim
participant "EstrategiaSJF" as SJF
participant "ReadyQueue" as RQ
participant "P1_CPU5" as P1
participant "P2_CPU3" as P2
participant "P3_CPU4" as P3

== Ejemplo: P1(CPU=5), P2(CPU=3), P3(CPU=4) arribando en diferentes momentos ==

note over Sim: t=0 - Arribo P1 (CPU=5)
Sim -> P1: estado = LISTO
Sim -> RQ: [P1]
Sim -> SJF: elegirSiguiente([P1])
SJF --> Sim: P1 (única opción)
Sim -> P1: estado = CORRIENDO

note over Sim: t=1 - Arribo P2 (CPU=3, menor que P1)
Sim -> P2: estado = LISTO
Sim -> RQ: [P1_CPU, P2]
note right: SJF no es expropiativo, P1 continúa

note over Sim: t=2 - Arribo P3 (CPU=4)  
Sim -> P3: estado = LISTO
Sim -> RQ: [P1_CPU, P2, P3]
note right: P1 sigue ejecutando hasta completar

note over Sim: t=5 - P1 termina
Sim -> P1: estado = TERMINADO
Sim -> SJF: elegirSiguiente([P2, P3])
SJF -> SJF: compararTiemposCPU(P2=3, P3=4)
SJF --> Sim: P2 (tiempo=3 < tiempo=4)
Sim -> P2: estado = CORRIENDO

note over Sim: t=8 - P2 termina
Sim -> P2: estado = TERMINADO  
Sim -> SJF: elegirSiguiente([P3])
SJF --> Sim: P3 (único restante)
Sim -> P3: estado = CORRIENDO

note over Sim: t=12 - P3 termina
Sim -> P3: estado = TERMINADO

note right of SJF
**Características SJF:**
- No expropiativo
- Selecciona proceso con menor tiempo CPU
- Minimiza tiempo promedio de espera
- Requiere conocer tiempos a priori
- Puede causar inanición de jobs largos
- Optimal para tiempo promedio turnaround
end note

@enduml

' ====================================================================
' DIAGRAMA ESPECÍFICO PARA SRTF (Shortest Remaining Time First) 
' ====================================================================

@startuml
title Secuencia SRTF - Shortest Remaining Time First (Expropiativo)  
participant "Simulador" as Sim
participant "EstrategiaSRTF" as SRTF
participant "ReadyQueue" as RQ
participant "P1_Rem5" as P1
participant "P2_Rem3" as P2
participant "P3_Rem4" as P3

== Ejemplo: P1(CPU=5), P2(CPU=3), P3(CPU=4) con expropiación ==

note over Sim: t=0 - Arribo P1 (tiempo restante=5)
Sim -> P1: estado = LISTO, tiempoRestante = 5
Sim -> RQ: [P1]
Sim -> SRTF: elegirSiguiente([P1])
SRTF --> Sim: P1 (única opción)
Sim -> P1: estado = CORRIENDO

note over Sim: t=1 - Arribo P2 (tiempo restante=3)
Sim -> P2: estado = LISTO, tiempoRestante = 3
Sim -> SRTF: verificarExpropiacion(P1_rem4, P2_rem3)
note right: P1 ejecutó 1u, le quedan 4u
SRTF --> Sim: EXPROPIACION_REQUERIDA (3 < 4)

Sim -> P1: expropiar(), estado = LISTO
P1 -> P1: tiempoRestante = 4 (ejecutó 1u)
Sim -> RQ: [P1, P2]
Sim -> SRTF: elegirSiguiente([P1, P2]) 
SRTF -> SRTF: compararTiemposRestantes(P1=4, P2=3)
SRTF --> Sim: P2 (tiempo restante menor)
Sim -> P2: estado = CORRIENDO

note over Sim: t=2 - Arribo P3 (tiempo restante=4)
Sim -> P3: estado = LISTO, tiempoRestante = 4
Sim -> SRTF: verificarExpropiacion(P2_rem2, P3_rem4)
note right: P2 ejecutó 1u, le quedan 2u
SRTF --> Sim: NO_EXPROPIACION (2 < 4)
Sim -> RQ: [P1, P2_CPU, P3] (P2 continúa)

note over Sim: t=4 - P2 termina
Sim -> P2: estado = TERMINADO
Sim -> SRTF: elegirSiguiente([P1, P3])
SRTF -> SRTF: compararTiemposRestantes(P1=4, P3=4)
SRTF --> Sim: P1 (empate, toma el primero por FIFO)
Sim -> P1: estado = CORRIENDO

note over Sim: t=8 - P1 termina su tiempo restante
Sim -> P1: estado = TERMINADO
Sim -> SRTF: elegirSiguiente([P3])
SRTF --> Sim: P3 (único restante)
Sim -> P3: estado = CORRIENDO

note over Sim: t=12 - P3 termina
Sim -> P3: estado = TERMINADO

note right of SRTF
**Características SRTF:**
- Expropiativo por tiempo restante
- Óptimo para tiempo promedio respuesta
- Actualiza tiempo restante continuamente
- Puede causar inanición extreme
- Mayor overhead por decisiones frecuentes
- Versión preemptive de SJF
end note

@enduml

' ====================================================================
' DIAGRAMA DE INTERACCIÓN CON E/S (TODOS LOS ALGORITMOS)
' ====================================================================

@startuml
title Interacción con E/S - Aplicable a Todos los Algoritmos
participant "Simulador" as Sim
participant "Scheduler" as Sched
participant "Proceso" as Proc
participant "DispositivoIO" as IO

== Proceso con Múltiples Ráfagas CPU-IO ==

note over Proc: Proceso con rafagasCPU=3, duracionCPU=4, duracionIO=2

Sim -> Sched: elegirSiguiente()
Sched --> Sim: Proceso
Sim -> Proc: estado = CORRIENDO
Proc -> Proc: ejecutarRafaga1() (4u)

note over Sim: Fin de primera ráfaga CPU
Sim -> Proc: completarRafaga()
Proc -> Proc: rafagasRestantes = 2
alt Quedan ráfagas
    Proc -> Proc: estado = BLOQUEADO
    Sim -> IO: iniciarOperacion(duracionIO=2)
    activate IO
    Sim -> Sim: agregarAListaBloqueados(proceso)
    
    note over IO: Operación E/S durante 2 unidades
    IO -> Sim: operacionCompleta()
    deactivate IO
    
    Sim -> Proc: estado = LISTO
    Sim -> Sim: agregarAReadyQueue(proceso)
    
    note over Sim: El proceso vuelve al final de la cola READY
    note over Sim: Debe esperar su turno según el algoritmo
end

== Segunda Ráfaga CPU ==
Sim -> Sched: elegirSiguiente() 
note right: El proceso debe esperar según algoritmo
Sched --> Sim: Proceso (cuando le toque)
Sim -> Proc: estado = CORRIENDO
Proc -> Proc: ejecutarRafaga2() (4u)

note over Sim: Fin de segunda ráfaga CPU
Sim -> Proc: completarRafaga()
Proc -> Proc: rafagasRestantes = 1

alt Quedan ráfagas  
    note over Sim: Repite patrón CPU-IO...
else Última ráfaga completada
    Proc -> Proc: estado = TERMINADO
end

note right of Sched
**Puntos Clave E/S:**
- Proceso va al final de READY tras I/O
- No conserva posición privilegiada
- Todos los algoritmos manejan igual
- El orden de retorno depende del scheduler
end note

@enduml