@startuml
title Shortest Job First (SJF) Mejorado - Con Estados Suspendidos
participant "AdaptadorSimuladorDominio" as Adaptador
participant "MotorSimulacion" as Motor
participant "EstrategiaSchedulerSjf" as SJF
participant "EstadoSistema" as Estado
participant "EventQueue" as EQ
participant "ReadyQ" as RQ
participant "BlockedQ" as BQ
participant "Logger" as Logger
participant "CPU" as CPU
participant "P1" as P1
participant "P2" as P2
participant "P3" as P3
participant "P4" as P4
participant "P5" as P5

== Configuración Inicial Mejorada ==
note over Motor: TIP=1, TFP=1, TCP=1
note over SJF: **SJF: Shortest Job First (NO expropiativo)**\nCriterio: trabajo_total_estimado (todas las ráfagas)\nExpropiación: NUNCA (soportaExpropiacion=false)\nCálculo: rafagasRestantes × duracionCPU\nTie-breaking: FIFO entre iguales trabajos totales
note over Estado: memoriaDisponible=1000, umbralSuspension=100
note over P1: P1: arribo=0, rafagas=3, **CPU=5**, trabajo_total=15, tamaño=150
note over P2: P2: arribo=1, rafagas=2, **CPU=6**, trabajo_total=12, tamaño=200
note over P3: P3: arribo=3, rafagas=4, **CPU=3**, trabajo_total=12, tamaño=100
note over P4: P4: arribo=5, rafagas=3, **CPU=4**, trabajo_total=12, tamaño=250
note over P5: P5: arribo=6, rafagas=2, **CPU=7**, trabajo_total=14, tamaño=180

note top of Motor: **Orden eventos simultáneos:**\n1.FIN_PROCESO 2.FIN_RAFAGA_CPU 3.EXPROPIACION\n4.FIN_IO 5.FIN_TIP 6.DISPATCH

== Bucle Principal SJF ==

loop while EventQueue not empty
    Motor -> EQ: popNext() [orden prioridad académica]
    EQ --> Motor: evento
    Motor -> Logger: registrar(t, tipo, pid, descripcion)

group t=0: JOB_LLEGA P1 (prioridad 0)
    Motor -> Estado: haySuficienteMemoria(150)
    Estado -> Motor: true
    ref over Motor, Estado : aplicarTIP(P1)\nNUEVO -> intermedio (t += TIP)
    Motor -> EQ: schedule(FIN_TIP, 1, "P1") [prioridad 5]
    Motor -> Logger: registrar(0, "JOB_LLEGA", "P1", "arribo trabajo_total=15")
end

group t=1: FIN_TIP P1 + JOB_LLEGA P2 (eventos simultáneos)
    note right: **Orden:** JOB_LLEGA(0) antes que FIN_TIP(5)
    
    == Procesamiento JOB_LLEGA P2 primero ==
    Motor -> Estado: haySuficienteMemoria(200)
    Estado -> Motor: true
    ref over Motor, Estado : aplicarTIP(P2)\nNUEVO -> intermedio (t += TIP)
    Motor -> EQ: schedule(FIN_TIP, 2, "P2") [prioridad 5]
    Motor -> Logger: registrar(1, "JOB_LLEGA", "P2", "arribo trabajo_total=12")
    
    == Procesamiento FIN_TIP P1 después ==
    Motor -> P1: estado = NUEVO → LISTO
    Motor -> Estado: reservarMemoria(150) → 850 disponible
    Motor -> RQ: push(P1) [ordenado por trabajo total]
    Motor -> SJF: ordenarCola([P1]) por trabajo_total
    SJF -> RQ: [P1] trabajo_total=15
    Motor -> Logger: registrar(1, "N->L", "P1", "TIP completado trabajo_total=15")
    
    == Auto-dispatch ==
    Motor -> EQ: schedule(DISPATCH, 1, "") [prioridad 6]
    
    == Procesamiento DISPATCH ==
    Motor -> SJF: elegirSiguiente([P1], 1)
    SJF -> Motor: P1 [única opción, trabajo_total=15]
    Motor -> RQ: remove(P1)
    ref over Motor, CPU : aplicarTCP()\nLISTO -> CORRIENDO (t += TCP)
    Motor -> P1: estado = LISTO → CORRIENDO
    Motor -> CPU: asignar(P1)
    Motor -> Estado: procesoEnCPU = P1
    Motor -> EQ: schedule(FIN_RAFAGA_CPU, 7, "P1") [t+TCP+5=7, prioridad 2]
    Motor -> Logger: registrar(1, "L->C", "P1", "dispatch + TCP")
    note right: **SJF Guard:** [no expropiativo] hasta completar ráfaga
end

group t=2: FIN_TIP P2 - NO EXPROPIACIÓN
    Motor -> P2: estado = NUEVO → LISTO
    Motor -> Estado: reservarMemoria(200) → 650 disponible
    Motor -> RQ: push(P2) [ordenado por trabajo total]
    Motor -> SJF: ordenarCola([P2]) por trabajo_total
    SJF -> RQ: [P2] trabajo_total=12
    Motor -> Logger: registrar(2, "N->L", "P2", "TIP completado trabajo_total=12")
    
    == NO hay evaluación de expropiación ==
    note right: **SJF Guard:** [no expropiativo] P1 continúa sin interrupciones
    Motor -> Logger: registrar(2, "NO_PREEMPT", "P2", "SJF no expropiativo")
end

group t=3: JOB_LLEGA P3 - ESPERA SIN EXPROPIACIÓN
    Motor -> Estado: haySuficienteMemoria(100)
    Estado -> Motor: true
    ref over Motor, Estado : aplicarTIP(P3)\nNUEVO -> intermedio (t += TIP)
    Motor -> EQ: schedule(FIN_TIP, 4, "P3") [prioridad 5]
    Motor -> Logger: registrar(3, "JOB_LLEGA", "P3", "arribo trabajo_total=12")
end

group t=4: FIN_TIP P3 - NO EXPROPIACIÓN
    Motor -> P3: estado = NUEVO → LISTO
    Motor -> Estado: reservarMemoria(100) → 550 disponible
    Motor -> RQ: push(P3) [ordenado por trabajo total]
    Motor -> SJF: ordenarCola([P2, P3]) por trabajo_total
    SJF -> RQ: [P2, P3] ambos trabajo_total=12 → orden FIFO
    Motor -> Logger: registrar(4, "N->L", "P3", "TIP completado trabajo_total=12")
    note right: **SJF Guard:** [no expropiativo] P1 continúa ejecutando
end

group t=7: FIN_RAFAGA_CPU P1 - SELECCIÓN POR TRABAJO TOTAL
    Motor -> P1: completarRafaga()
    alt [necesita I/O] P1 tiene más ráfagas
        Motor -> P1: estado = CORRIENDO → BLOQUEADO
        Motor -> CPU: liberar()
        Motor -> BQ: push(P1, ioSpec)
        Motor -> EQ: schedule(FIN_IO, 11, "P1") [t+4=11, prioridad 4]
        Motor -> Logger: registrar(7, "C->B", "P1", "inicia I/O - trabajo restante actualizado")
    else [terminó] todas las ráfagas completadas
        Motor -> EQ: schedule(FIN_PROCESO, 7, "P1") [prioridad 1]
    end
    
    == Dispatch siguiente proceso por trabajo total ==
    Motor -> EQ: schedule(DISPATCH, 7, "") [prioridad 6]
    
    == Procesamiento DISPATCH ==
    Motor -> SJF: elegirSiguiente([P2, P3], 7)
    SJF -> SJF: comparar trabajos totales
    note right: **P2:** trabajo_total=12, **P3:** trabajo_total=12 → empate
    SJF -> SJF: aplicar tie-breaking FIFO
    SJF -> Motor: P2 [mismo trabajo_total=12, pero P2 llegó primero]
    Motor -> RQ: remove(P2) [cola queda = [P3]]
    ref over Motor, CPU : aplicarTCP()\nLISTO -> CORRIENDO (t += TCP)
    Motor -> P2: estado = LISTO → CORRIENDO
    Motor -> CPU: asignar(P2)
    Motor -> EQ: schedule(FIN_RAFAGA_CPU, 14, "P2") [t+TCP+6=14, prioridad 2]
    Motor -> Logger: registrar(7, "L->C", "P2", "dispatch por menor trabajo_total")
    note right: **SJF Guard:** [trabajo_total(P2=12) == trabajo_total(P3=12)] → FIFO
end

group Recalculo de trabajo total tras I/O
    note over Motor: **Actualización trabajo total después de I/O**
    
    group t=11: FIN_IO P1 - TRABAJO TOTAL REDUCIDO
        Motor -> BQ: remove(P1)
        Motor -> P1: estado = BLOQUEADO → LISTO
        Motor -> SJF: recalcularTrabajoTotal(P1)
        SJF -> SJF: trabajo_total = rafagas_restantes × duracion_CPU
        note right: **P1 tras I/O:** trabajo_total = 2×5 = 10 (menor)
        Motor -> RQ: push(P1) [reordenado por nuevo trabajo_total]
        Motor -> SJF: ordenarCola([P3, P1]) por trabajo_total
        SJF -> RQ: [P1(10), P3(12)] P1 ahora tiene menor trabajo
        Motor -> Logger: registrar(11, "B->L", "P1", "I/O completado, trabajo_total=10")
        note right: **SJF Guard:** [no expropiativo] P2 continúa hasta completar
    end
end

group Siguiente dispatch tras P2
    note over Motor: **Cuando P2 termine, seleccionar por trabajo total actualizado**
    
    group Ejemplo: t=14 P2 termina ráfaga
        Motor -> SJF: elegirSiguiente([P1, P3], 14)
        SJF -> Motor: P1 [trabajo_total=10 < trabajo_total(P3)=12]
        Motor -> Logger: registrar(14, "SELECT", "P1", "menor trabajo_total tras I/O")
        note right: **SJF Guard:** [trabajo_total(P1=10) < trabajo_total(P3=12)] ✓
    end
end

note over Motor, Logger: **SJF continúa sin expropiación**\n• Selección por trabajo_total_estimado\n• NO hay expropiación durante ejecución\n• Recálculo de trabajo tras cada I/O\n• Tie-breaking FIFO para trabajos iguales

end
    Motor -> P2: estado = NUEVO → LISTO
    Motor -> Estado: reservar memoria(200) → 650 disponible
    Motor -> ReadyQ: agregar P2
    Motor -> SJF: debeExpropiar(P1, P2, 2)
    SJF -> Motor: false (soportaExpropiacion = false)
    note right: **SJF:** P2 espera aunque servicio=2×6=12 < P1 restante
    Motor -> ReadyQ: [P2] (P1 continúa en CPU)
end

group t=3: Arribo P3
    Sys -> P3: JOB_LLEGA
    P3 -> P3: estado = NUEVO
end

group t=4: P3 entra - JOB MÁS CORTO
    Sys -> P3: estado = LISTO
    Sys -> SQ: insertar P3 (CPU=3)
    note right: **SJF:** P3(CPU=3) < P2(CPU=6) → reordenar cola
    Sys -> SQ: [P3(CPU=3), P2(CPU=6)] ordenada por duración
end

group t=5: Arribo P4
    Sys -> P4: JOB_LLEGA
    P4 -> P4: estado = NUEVO
end

group t=6: P1 termina ráfaga 1, P4 entra, Arribo P5
    CPU -> P1: fin ráfaga CPU
    P1 -> P1: estado = BLOQUEADO (I/O 4u hasta t=10)
    
    Sys -> P4: estado = LISTO
    Sys -> SQ: insertar P4 (CPU=4) 
    Sys -> P5: JOB_LLEGA
    P5 -> P5: estado = NUEVO
    
    note right: **SJF:** Seleccionar job más corto disponible
    note right: P3(CPU=3) < P4(CPU=4) < P2(CPU=6)
    
    SQ -> CPU: despachar P3 (shortest job)
    CPU -> P3: estado = CORRIENDO
    P3 -> P3: ejecutar ráfaga 1 (3u COMPLETA)
    Sys -> SQ: [P4(CPU=4), P2(CPU=6)] (P1 en I/O)
end

group t=7: P5 entra al sistema
    Sys -> P5: estado = LISTO  
    Sys -> SQ: insertar P5 (CPU=7)
    note right: **SJF:** P4(CPU=4) < P2(CPU=6) < P5(CPU=7)
    Sys -> SQ: [P4(CPU=4), P2(CPU=6), P5(CPU=7)] ordenada
end

group t=9: P3 termina ráfaga 1
    CPU -> P3: fin ráfaga CPU
    P3 -> P3: estado = BLOQUEADO (I/O 2u hasta t=11)
    
    SQ -> CPU: despachar P4 (shortest available)
    CPU -> P4: estado = CORRIENDO
    P4 -> P4: ejecutar ráfaga 1 (4u COMPLETA)
    Sys -> SQ: [P2(CPU=6), P5(CPU=7)] (P1, P3 en I/O)
end

group t=10: P1 termina I/O
    P1 -> P1: fin I/O, estado = LISTO
    P1 -> P1: ráfaga 2 duración = 5u
    Sys -> SQ: insertar P1 (CPU=5)
    note right: **SJF:** P1(CPU=5) < P2(CPU=6) < P5(CPU=7)  
    Sys -> SQ: [P1(CPU=5), P2(CPU=6), P5(CPU=7)] reordenada
end

group t=11: P3 termina I/O
    P3 -> P3: fin I/O, estado = LISTO
    P3 -> P3: ráfaga 2 duración = 3u (shortest)
    Sys -> SQ: insertar P3 (CPU=3)
    note right: **SJF:** P3(CPU=3) shortest again!
    Sys -> SQ: [P3(CPU=3), P1(CPU=5), P2(CPU=6), P5(CPU=7)]
end

group t=13: P4 termina ráfaga 1  
    CPU -> P4: fin ráfaga CPU
    P4 -> P4: estado = BLOQUEADO (I/O 2u hasta t=15)
    
    SQ -> CPU: despachar P3 (shortest job)
    CPU -> P3: estado = CORRIENDO
    P3 -> P3: ejecutar ráfaga 2 (3u COMPLETA) 
    Sys -> SQ: [P1(CPU=5), P2(CPU=6), P5(CPU=7)] (P4 en I/O)
end

group t=15: P4 termina I/O
    P4 -> P4: fin I/O, estado = LISTO  
    P4 -> P4: ráfaga 2 duración = 4u
    Sys -> SQ: insertar P4 (CPU=4)
    note right: **SJF:** P4(CPU=4) < P1(CPU=5) < P2(CPU=6) < P5(CPU=7)
    Sys -> SQ: [P4(CPU=4), P1(CPU=5), P2(CPU=6), P5(CPU=7)]
end

group t=16: P3 termina ráfaga 2 - SIGUIENTE MÁS CORTO
    CPU -> P3: fin ráfaga CPU
    P3 -> P3: estado = BLOQUEADO (I/O 2u hasta t=18)
    
    SQ -> CPU: despachar P4 (shortest available)
    CPU -> P4: estado = CORRIENDO  
    P4 -> P4: ejecutar ráfaga 2 (4u COMPLETA)
    Sys -> SQ: [P1(CPU=5), P2(CPU=6), P5(CPU=7)] (P3 en I/O)
end

note right of SQ
**Patrón SJF Non-Preemptive:**
- Selección por duración CPU mínima
- NO interrumpe jobs en ejecución  
- Reordena cola en cada llegada/retorno I/O
- Minimiza tiempo promedio respuesta
- Puede causar starvation jobs largos
- Predice duración próxima ráfaga
- Optimal para minimizar waiting time
end note

@enduml