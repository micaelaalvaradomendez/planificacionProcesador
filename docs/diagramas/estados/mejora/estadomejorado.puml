@startuml Estados_Proceso_Academicamente_Correcto
title Diagrama de Estados - Ciclo de Vida de Procesos (Versión Académica Corregida)

' === DEFINICIÓN DE ESTADOS CANÓNICOS ===

state "Estados Fundamentales del Sistema" as sistema {
  
  state NUEVO {
    NUEVO : **Estado Inicial:** Proceso arriba al sistema
    NUEVO : **Operación SO:** TIP (Tiempo Ingreso Proceso)
    NUEVO : **Duración:** TIP unidades (tiempo de SO)
    NUEVO : **Disponibilidad:** NO disponible para scheduling
    NUEVO : **Evento salida:** FIN_TIP → transición a LISTO
    NUEVO : --
    NUEVO : ⚠️ **CRÍTICO:** TIP NO cuenta como tiempo en READY
    NUEVO : ✓ **Métrica:** TIP es overhead del Sistema Operativo
  }
  
  state LISTO {
    LISTO : **Estado Ready Queue:** Disponible para scheduling
    LISTO : **Ordenamiento:** Según algoritmo de planificación
    LISTO : **Tiempo espera:** Inicia DESPUÉS de completar TIP
    LISTO : **Evento entrada:** FIN_TIP (desde NUEVO) o regreso de I/O
    LISTO : **Evento salida:** DISPATCH → transición a CORRIENDO
    LISTO : --
    LISTO : ✓ **Aging (Priority):** Solo aplica mientras está en LISTO
    LISTO : ✓ **Ready vacío:** CPU pasa a estado IDLE
  }
  
  state CORRIENDO {
    CORRIENDO : **Estado CPU:** Proceso ejecutando activamente
    CORRIENDO : **Ráfaga actual:** Consumiendo tiempo de CPU
    CORRIENDO : **Quantum (RR):** Contador activo hasta expiración
    CORRIENDO : **Expropiación:** Según política de planificación
    CORRIENDO : **Eventos salida:** FIN_RAFAGA, FIN_PROCESO, QUANTUM_EXPIRES
    CORRIENDO : --
    CORRIENDO : ✓ **Métricas:** Tiempo de CPU utilizado
    CORRIENDO : ⚠️ **Solo UN proceso** puede estar CORRIENDO
  }
  
  state BLOQUEADO {
    BLOQUEADO : **Estado I/O:** Proceso realizando operación de entrada/salida  
    BLOQUEADO : **CPU:** NO consume tiempo de procesador
    BLOQUEADO : **Duración:** Tiempo fijo de I/O del proceso
    BLOQUEADO : **Evento salida:** FIN_IO → regreso instantáneo a LISTO
    BLOQUEADO : --
    BLOQUEADO : ✓ **Múltiples procesos** pueden estar BLOQUEADOS
    BLOQUEADO : ✓ **I/O concurrente:** Dispositivos independientes
  }
  
  state TERMINADO {
    TERMINADO : **Estado Final:** Todas las ráfagas CPU completadas
    TERMINADO : **Operación SO:** TFP (Tiempo Finalización Proceso)
    TERMINADO : **Duración:** TFP unidades (tiempo de SO)
    TERMINADO : **Métricas:** Cálculo final de tiempos de respuesta
    TERMINADO : **Estado:** Proceso completado y liberado
    TERMINADO : --
    TERMINADO : ✓ **Una vez terminado:** NO puede cambiar de estado
  }
  
  state CPU_IDLE {
    CPU_IDLE : **CPU Ociosa:** No hay procesos en Ready Queue
    CPU_IDLE : **Duración:** Hasta próximo evento (arribo o fin I/O)
    CPU_IDLE : **Métrica:** Tiempo de ociosidad del sistema
    CPU_IDLE : **Transición:** Automática cuando Ready Queue no vacío
    CPU_IDLE : --
    CPU_IDLE : ✓ **Importante:** Afecta utilización del sistema
  }
}

' === TRANSICIONES CANÓNICAS ===

[*] --> NUEVO : **ARRIBO**\nProceso llega al sistema\n(t = tiempo_arribo)

NUEVO --> LISTO : **FIN_TIP**\n• INSTANTÁNEO (Δt=0)\n• ❌ **SIN TCP**\n• ✅ **CON TIP** (tiempo SO)

LISTO --> CORRIENDO : **DISPATCH**\n• ✅ **CON TCP** (cambio contexto)\n• Evento explícito en log\n• Selección según algoritmo

CORRIENDO --> BLOQUEADO : **FIN_RAFAGA_CPU**\n• INSTANTÁNEO (Δt=0)\n• ❌ **SIN TCP**\n• Inicia I/O inmediatamente\n• rafagasRestantes > 0

BLOQUEADO --> LISTO : **FIN_IO**\n• INSTANTÁNEO (Δt=0)\n• ❌ **SIN TCP**\n• Puede gatillar expropiación\n• (SRTF/Priority evalúan)

CORRIENDO --> TERMINADO : **FIN_PROCESO**\n• ✅ **CON TFP** (tiempo SO)\n• rafagasRestantes = 0\n• Métricas finalizadas

' === TRANSICIONES DE EXPROPIACIÓN ===

CORRIENDO --> LISTO : **EXPROPIACIÓN**\n• ✅ **CON TCP** (cambio contexto)\n• Solo políticas expropiativas\n• Causas: quantum, prioridad, SRTF

LISTO --> CPU_IDLE : **READY_QUEUE_VACÍA**\n• Ready Queue queda sin procesos\n• CPU entra en estado ocioso

CPU_IDLE --> LISTO : **PROCESO_DISPONIBLE**\n• Nuevo proceso llega a READY\n• (FIN_TIP o FIN_IO)

' === REGLAS POR POLÍTICA DE PLANIFICACIÓN ===

note top of sistema
**ORDEN DE EVENTOS SIMULTÁNEOS (OBLIGATORIO)**
**Prioridad de resolución cuando eventos coinciden en tiempo:**

**1.** C→T (FIN_PROCESO)
**2.** C→B (FIN_RAFAGA_CPU → I/O)  
**3.** C→L (EXPROPIACIÓN - quantum/prioridad/SRTF)
**4.** B→L (FIN_IO)
**5.** N→L (FIN_TIP)
**6.** L→C (DISPATCH)

⚠️ **Ejemplo crítico:** Si FIN_RAFAGA_CPU coincide con QUANTUM_EXPIRES,
primero se procesa FIN_RAFAGA_CPU → **NO se cobra TCP** por expropiación.
end note

note right of sistema
**TIEMPOS DE SISTEMA OPERATIVO (TIP/TCP/TFP)**

**TIP (Tiempo Ingreso Proceso):**
• Solo en N→L (admisión al sistema)
• Es tiempo de SO, NO de proceso
• No cuenta como tiempo en READY

**TCP (Tiempo Cambio Proceso):**
• Solo en L→C (DISPATCH)
• Solo en C→L (EXPROPIACIÓN)
• NUNCA en C→B ni B→L

**TFP (Tiempo Finalización Proceso):**
• Solo en C→T (terminación)
• Es tiempo de SO para cleanup

⚠️ **ERROR COMÚN:** Cobrar TCP en transiciones instantáneas
end note

' === COMPORTAMIENTOS ESPECÍFICOS POR ALGORITMO ===

state "Reglas por Algoritmo de Planificación" as algoritmos {
  
  state FCFS_Rules {
    FCFS_Rules : **FCFS - First Come First Served**
    FCFS_Rules : --
    FCFS_Rules : ✅ **L→C:** Orden estricto FIFO
    FCFS_Rules : ❌ **C→L:** NO expropiativo
    FCFS_Rules : ✅ **TCP:** Solo en DISPATCH (L→C)
    FCFS_Rules : ✅ **Tie-breaker:** Orden de llegada a READY
    FCFS_Rules : --
    FCFS_Rules : **Transiciones permitidas:**
    FCFS_Rules : N→L, L→C, C→B, B→L, C→T
  }
  
  state RR_Rules {
    RR_Rules : **RR - Round Robin**  
    RR_Rules : --
    RR_Rules : ✅ **L→C:** DISPATCH + programa QUANTUM_EXPIRES
    RR_Rules : ✅ **C→L:** QUANTUM_EXPIRES (con TCP)
    RR_Rules : ✅ **Quantum:** Reinicia en cada DISPATCH
    RR_Rules : ✅ **Cola circular:** Expropiado va al final
    RR_Rules : --
    RR_Rules : **Caso especial:** Si FIN_RAFAGA coincide con
    RR_Rules : QUANTUM_EXPIRES → FIN_RAFAGA tiene prioridad
    RR_Rules : → ❌ NO se cobra TCP por quantum
  }
  
  state SJF_Rules {
    SJF_Rules : **SJF - Shortest Job First**
    SJF_Rules : --
    SJF_Rules : ✅ **L→C:** Selección por próxima ráfaga CPU más corta
    SJF_Rules : ❌ **C→L:** NO expropiativo
    SJF_Rules : ✅ **Criterio:** Duración de ráfaga, NO trabajo total
    SJF_Rules : ✅ **Tie-breaker:** Orden de llegada a READY
    SJF_Rules : --
    SJF_Rules : ⚠️ **TERMINOLOGÍA:** "Job" = próxima ráfaga CPU
    SJF_Rules : ⚠️ **NO confundir:** Con tiempo total del proceso
  }
  
  state SRTF_Rules {
    SRTF_Rules : **SRTF - Shortest Remaining Time First**
    SRTF_Rules : --
    SRTF_Rules : ✅ **L→C:** Selección por menor tiempo restante
    SRTF_Rules : ✅ **C→L:** Expropiación si llega menor restante
    SRTF_Rules : ✅ **Evaluación:** En cada N→L y B→L
    SRTF_Rules : ✅ **Criterio:** Resto de ráfaga ACTUAL
    SRTF_Rules : --
    SRTF_Rules : **Condición expropiación:**
    SRTF_Rules : tiempo_restante_nuevo < tiempo_restante_actual
    SRTF_Rules : **Empate:** Mantener proceso actual (NO expropiar)
  }
  
  state Priority_Rules {
    Priority_Rules : **Priority - Planificación por Prioridad**
    Priority_Rules : --
    Priority_Rules : ✅ **L→C:** Selección por mayor prioridad
    Priority_Rules : ✅ **C→L:** Expropiación por prioridad mayor
    Priority_Rules : ✅ **Convención:** Menor número = Mayor prioridad
    Priority_Rules : ✅ **Aging:** Solo mientras está en READY
    Priority_Rules : --
    Priority_Rules : **Condición expropiación:**
    Priority_Rules : prioridad_nuevo < prioridad_actual
    Priority_Rules : **Empate:** Mantener proceso actual (NO expropiar)
    Priority_Rules : **Anti-starvation:** Aging incrementa prioridad
  }
}

note bottom of algoritmos
**LOG DE EVENTOS COMO FUENTE DE VERDAD**

• Toda transición debe registrarse en el log con timestamp exacto
• Incluir metadatos: TCP cobrado, causa de expropiación, etc.
• Gantt y métricas se reconstruyen ÚNICAMENTE del log
• Validación: verificar que transiciones respetan reglas del algoritmo

**MÉTRICAS DERIVADAS DEL LOG:**
• Tiempo espera = suma de intervalos en LISTO (después de TIP)
• Tiempo respuesta = tiempo_finalizacion - tiempo_arribo  
• Tiempo CPU = suma de intervalos en CORRIENDO
• TCP total = suma de todos los TCP cobrados
• Utilización = (tiempo_CPU_total + TCP_total) / tiempo_simulacion
end note

' === CASOS ESPECIALES Y VALIDACIONES ===

note left of sistema
**VALIDACIONES CRÍTICAS**

❌ **Errores a evitar:**
• TCP en C→B o B→L
• DISPATCH sin TCP  
• TIP contando como tiempo READY
• TFP en transición diferente a C→T
• Saltos directos N→C o B→C
• Empates que expropian (mantener actual)

✅ **Verificaciones obligatorias:**
• Solo UN proceso CORRIENDO simultáneamente
• Ready vacío → CPU_IDLE
• Orden de eventos simultáneos respetado  
• TCP solo donde corresponde
• Estados canónicos únicamente
end note

@enduml
