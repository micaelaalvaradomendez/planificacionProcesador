@startuml 07-secuencia-spn
title SPN – Shortest Process Next (no expropiativo)

actor "Motor" as ENG
participant "EventQueue\n(t, prioridad, _seq)" as EQ
participant "SchedulerSPN\n(clave: ráfaga próxima)" as SCH
participant "CPU" as CPU
participant "Proceso A" as PA
participant "Proceso B" as PB

== Arribos con TIP aplicado previamente ==
ENG -> EQ : push( N→L @ tA, A )
ENG -> EQ : push( N→L @ tB, B )

EQ -> ENG : pop() = N→L @ tA
ENG -> SCH : onAdmit(A)

EQ -> ENG : pop() = N→L @ tB
ENG -> SCH : onAdmit(B)

== Despacho por ráfaga más corta ==
ENG -> SCH : next()  ' elige al de menor ráfaga próxima
SCH --> ENG : A
ENG -> EQ : push( L→C @ t0, A )

EQ -> ENG : pop() = L→C @ t0
ENG -> CPU : abrir slice en t_s = t0 + TCP
note right of CPU
  SPN NO expropia:
  si arriba uno con ráfaga más corta mientras corre otro,
  el que corre continúa hasta fin de su ráfaga.
end note

== Fin intermedio o total de A ==
ENG -> EQ : push( C→B @ (t_s + rA), A )  ' si quedan ráfagas
... o ...
ENG -> EQ : push( C→T @ (t_s + rA + TFP), A )  ' si era última

== Reingreso o siguiente despacho ==
EQ -> ENG : pop() = B→L @ (t_s + rA + bloqueoES)  ' si C→B
ENG -> SCH : onReady(A)                           ' vuelve a READY

ENG -> SCH : next()  ' ahora gana B si su ráfaga es la más corta
SCH --> ENG : B
ENG -> EQ : push( L→C @ t1, B )

EQ -> ENG : pop() = L→C @ t1
ENG -> CPU : abrir slice en t_s' = t1 + TCP

legend right
  Claves (SPN):
   • Selección por menor ráfaga PRÓXIMA (no restante global).
   • No hay expropiación: arribos más cortos NO interrumpen al que está corriendo.
   • Empates: romper por orden estable (_seq/arribo).
   • Prioridades de eventos: C→T(1) > C→B(2) > C→L(3) > B→L(4) > N→L(5) > L→C(6).
endlegend
@enduml
