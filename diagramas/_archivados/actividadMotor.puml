@startuml 02-actividad-motor
title Motor de Simulación (Event Loop) – Orden (t, prioridad) estable

start

:Inicializar cola de eventos (priority queue ordenada por\n(tiempo, prioridad) con orden estable);
note right
  Regla de orden:
  • Primero por tiempo t ascendente
  • Luego por prioridad ascendente (1 mejor)
  • A igualdad de (t, prioridad) mantener orden de inserción
  
  **Guard por tick:**
  • A lo sumo un L→C por tiempo t
  • Comparador: (t asc, prioridad asc) + orden estable
  • Con bloqueoES=0, C→B y B→L coinciden en t; evita doble L→C@t
end note

repeat
  :pop() -> evento = (t, tipo, pid, meta...);

  if (¿evento válido?) then (sí)
    if (tipo == "C→T") then (sí)
      :Aplicar transición C→T (finalización)\n• validar legalidad\n• actualizar estado=F\n• Evento **C→T @ t_fin + TFP** (no CPU). La CPU queda libre desde t_fin;
      :Liberar CPU / recursos;
      :Reevaluar despacho (si hay procesos en L, planificador puede generar L→C);
    elseif (tipo == "C→B") then (sí)
      :Aplicar transición C→B (bloqueo por E/S)\n• validar legalidad\n• estado=B\n• **Programar B→L @(t + bloqueoES)** (si bloqueoES=0 coincide con t);
      :Liberar CPU;
      :Reevaluar despacho (posible L→C);
    elseif (tipo == "C→L") then (sí)
      :Aplicar transición C→L (expropiación)\n• validar legalidad\n• estado=L\n• costo TCP;
      :Insertar en cola de listos (READY);
      :Reevaluar despacho (L→C si corresponde);
    elseif (tipo == "B→L") then (sí)
      :Aplicar transición B→L (fin de E/S)\n• validar legalidad\n• estado=L;
      :Reevaluar despacho (L→C si CPU libre o política lo decide);
    elseif (tipo == "N→L") then (sí)
      :Aplicar transición N→L (admisión)\n• validar legalidad\n• estado=L\n• aplicar TIP;
      :Opcional: evaluar despacho inmediato (L→C) si CPU libre;
    elseif (tipo == "L→C") then (sí)
      :Aplicar transición L→C (despacho a CPU)\n• validar legalidad\n• estado=C;
      note right
        FCFS (sandbox): programa fin de ráfaga actual a t + restante.
        Si era la última → C→T; si no → C→B.
        Con bloqueoES=0, se agenda B→L al mismo t del C→B (por cola estable).
        **TCP**: tStart = t + TCP → los slices comienzan en tStart 
        (no contaminar ráfaga/quantum).
        
        Timer RR: push(C→L @ t_s + q); el quantum no incluye TCP.
      end note
      :Programar siguiente evento de CPU según ráfaga:\n– Si era última ráfaga: programar C→T\n– Si quedan ráfagas: programar C→B\n– Si política expropiativa: también programar C→L al expirar quantum;
    else (desconocido)
      :Descartar / loggear evento inválido;
    endif
  else (no)
    :Descartar / loggear evento corrupto;
  endif

repeat while (¿cola NO vacía?) is (sí)
-> no;
stop
@enduml
