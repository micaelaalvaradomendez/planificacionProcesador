@startuml 05-secuencia-costos
title Secuencia – Aplicación temporal de TIP / TCP / TFP (no son CPU)

actor "Motor" as ENG
participant "EventQueue\n(t, prioridad, _seq)" as EQ
participant "Scheduler" as SCH
participant "CPU" as CPU
participant "Proceso(pid)" as P
participant "E/S" as IO

' ===== Arribo y Admisión con TIP =====
== Arribo ==
ENG -> EQ : push( N→L_raw @ t_arribo, pid )

EQ -> ENG : pop() = N→L_raw @ t_arribo
ENG -> EQ : push( N→L @ (t_arribo + TIP), pid )
note right
  TIP desplaza la admisión:
  • N→L ocurre en t_arribo + TIP
  • TIP NO es CPU ni servicio
end note

EQ -> ENG : pop() = N→L @ (t_arribo + TIP)
ENG -> SCH : onAdmit(pid)

' ===== Despacho con TCP =====
== Despacho ==
ENG -> SCH : next()
SCH --> ENG : pid
ENG -> EQ : push( L→C @ t_despacho, pid )

EQ -> ENG : pop() = L→C @ t_despacho
ENG -> CPU : reservar CPU (overhead TCP)
ENG -> CPU : abrir slice en (t_despacho + TCP)
note over CPU
  TCP desplaza el INICIO del slice.
  • El tiempo de ráfaga/quantum empieza a contar
    desde (t_despacho + TCP)
  • TCP NO es servicio
end note

' ===== Fin de ráfaga intermedia (sin TFP) =====
== Fin ráfaga intermedia ==
ENG -> EQ : push( C→B @ (t_start + ráfaga), pid )
EQ -> ENG : pop() = C→B @(t_start+ráfaga)
ENG -> CPU : cerrar slice [t_start, t_start+ráfaga]
ENG -> P : estado = B
ENG -> EQ : push( B→L @ (t_start + ráfaga + bloqueoES), pid )
note right
  B→L no consume CPU:
  • reingresa a READY en (t + bloqueoES)
end note

' ===== Reingreso y nuevo despacho (TCP nuevamente) =====
== Reingreso desde E/S ==
EQ -> ENG : pop() = B→L @ (t_reingreso)
ENG -> SCH : onReady(pid)
ENG -> SCH : next() (si CPU libre)
SCH --> ENG : pid
ENG -> EQ : push( L→C @ t_reingreso, pid )

EQ -> ENG : pop() = L→C @ t_reingreso
ENG -> CPU : abrir nuevo slice en (t_reingreso + TCP)

' ===== Fin TOTAL de proceso con TFP =====
== Última ráfaga ==
ENG -> EQ : push( C→T @ (t_start2 + ráfaga_final + TFP), pid )
note right
  TFP desplaza el CIERRE del proceso:
  • C→T ocurre en fin_ráfaga + TFP
  • TFP NO es CPU ni servicio
end note

note right
  La CPU se libera y el slice se cierra en tFinCPU.
  El evento C→T ocurre en tFinCPU + TFP, pero NO ocupa CPU.
  El siguiente proceso puede comenzar en tFinCPU.
end note

' ===== Recordatorios =====
note bottom
  **Reglas (Paso 5 - Implementación con gatillo):**
  • TIP desplaza N→L; TCP desplaza el inicio del slice (L→C);
    TFP desplaza C→T.
  • **CPU se libera en tFinCPU; C→T ocurre en tFinCPU+TFP (no CPU).**
  • **Gatillo L→C @ tFinCPU**: cierra slice y libera CPU antes del C→T.
  • TIP/TCP/TFP NO se suman al servicio (suma de ráfagas CPU).
  • ráfaga/quantum arrancan a contar desde (t + TCP).
  • B→L es instantáneo (no usa CPU); el costo es bloqueoES.
end note
@enduml
