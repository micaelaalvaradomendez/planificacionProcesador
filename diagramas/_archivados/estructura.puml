@startuml Estructura - Mapa de Archivos

!define MODEL_COLOR #E8F4FD
!define ENGINE_COLOR #FDF2E9
!define SCHED_COLOR #E8F8F5
!define IO_COLOR #F3E5F5
!define METRICS_COLOR #EBF5FB
!define GANTT_COLOR #FADBD8
!define STORES_COLOR #FDEAA7
!define ROUTES_COLOR #D5E8D4
!define TEST_COLOR #FFF2CC

skinparam shadowing false
skinparam defaultTextAlignment left
skinparam packageStyle rectangle
skinparam ArrowColor #666666
skinparam PackageBorderColor #999999
skinparam RectangleBorderColor #BBBBBB
skinparam NoteBackgroundColor #FFFEF5
skinparam NoteBorderColor #E6D8A8
skinparam minClassWidth 180
skinparam maxMessageSize 150
skinparam nodesep 20
skinparam ranksep 30
hide circle

title Proyecto Simulador de Planificación – Mapa de Archivos

package "src" as SRC {

  package "lib" as LIB {

      package "model" as MODEL {
        rectangle "proceso.ts" as proceso_ts
        rectangle "rafaga.ts" as rafaga_ts
        rectangle "estados.ts" as estados_ts
        rectangle "costos.ts" as costos_ts
        
        proceso_ts -[hidden]down-> rafaga_ts
        rafaga_ts -[hidden]down-> estados_ts
        estados_ts -[hidden]down-> costos_ts

        note right of proceso_ts
          **✓ Implementado**
          • Tipos de Proceso (pid, arribo, ráfagas)
          • Estado del proceso (N, L, C, B, F)
          • servicioTotal() - suma de ráfagas CPU
          • isProcesoValido() - validación básica
        end note

        note right of rafaga_ts
          **✓ Implementado**
          • Utilidades para manejar rafagas
          • Índice/actual y chequeos de restantes
          • rafagaActual() - obtiene ráfaga por índice
          • quedanRafagas() - verifica ráfagas restantes
        end note

        note right of estados_ts
          **✓ Implementado**
          • Definición de estados
          • Reglas de transición válidas (invariantes)
          • Estados canónicos (N,L,C,B,F)
          • isTransicionLegal() - validador de transiciones
          • assertTransicionLegal() - error si ilegal
          • transicionarEstado() - transición inmutable
        end note

        note right of costos_ts
          **✓ Implementado**
          • Interface Costos (TIP, TCP, TFP, bloqueoES)
          • COSTOS_DEF - defaults (bloqueoES=25)
          • validarCostos() - verifica valores ≥ 0
          • makeCostos() - constructor saneado
        end note
      }

      package "engine" as ENGINE {
        rectangle "types.ts" as engine_types_ts
        rectangle "queue.ts" as queue_ts
        rectangle "invariants.ts" as invariants_ts
        rectangle "telemetry.ts" as telemetry_ts
        rectangle "engine.ts" as engine_ts
        
        engine_types_ts -[hidden]down-> queue_ts
        queue_ts -[hidden]down-> invariants_ts
        invariants_ts -[hidden]down-> telemetry_ts
        telemetry_ts -[hidden]down-> engine_ts

        note right of engine_types_ts
          **✓ Implementado**
          • Tipos del motor (EventType, SimEvent)
          • Estructura de traza (slices, eventos)
          • Contratos de entrada/salida de run()
        end note

        note right of queue_ts
          **✓ Implementado**
          • Cola de eventos
          • Orden por timestamp + prioridad de evento
        end note

        note right of invariants_ts
          **✓ Implementado** <<nuevo>>
          • Invariantes críticos del motor
          • assertSingleCPU() - un solo proceso en CPU
          • assertNoNegativeRestante() - restante >= 0
          • assertValidEnqueue() - no encolar restante <= 0
          • logSliceEvent() - debug estructurado de slices
        end note

        note right of telemetry_ts
          **✓ Implementado** <<nuevo>>
          • Wrapper condicional para telemetría
          • TELEMETRY_CONFIG - habilitar en desarrollo
          • TelemetryGuards - invariants condicionales
          • Configuración por NODE_ENV y DEBUG_SLICES
        end note

        note right of engine_ts
          **✓ Implementado** <<mod - Paso 7>>
          • runFCFSSandbox() - motor FCFS completo
          • runRR() - motor Round Robin con quantum
          • runSPN() - motor SPN (no expropiativo) <<nuevo>>
          • runSRTN() - motor SRTN con expropiación <<nuevo>>
          • getNextBurst() / getRemainingNow() helpers
          • tryPreemptIfNeeded() - hook expropiación SRTN
          • Guard anti-doble-dispatch por tick
          • Estado runtime por proceso (idxRafaga, restante)
          • Costos TIP/TCP/TFP integrados
          • Bloqueos E/S: B→L @ t+bloqueoES
          • Validación C→T stale por expectedSliceStart
          • NOW timer para SRTN
        end note
      }

      package "scheduler" as SCHED {
        rectangle "scheduler.ts" as scheduler_ts
        rectangle "ready-queue.ts" as ready_queue_ts
        rectangle "fcfs.ts" as fcfs_ts
        rectangle "rr.ts" as rr_ts
        rectangle "spn.ts" as spn_ts
        rectangle "srtn.ts" as srtn_ts
        rectangle "priority.ts" as priority_ts
        
        scheduler_ts -[hidden]down-> ready_queue_ts
        ready_queue_ts -[hidden]down-> fcfs_ts
        fcfs_ts -[hidden]down-> rr_ts
        rr_ts -[hidden]down-> spn_ts
        spn_ts -[hidden]down-> srtn_ts
        srtn_ts -[hidden]down-> priority_ts

        note right of scheduler_ts
          **✓ Implementado** <<mod>>
          • IScheduler - interfaz completa de planificadores
          • BaseScheduler - clase base abstracta
          • Métodos: onAdmit, onReady, onBlock, onFinish, next()
          • onDesalojoActual?() - re-encolado opcional
          • compareForPreemption?() - hook expropiación opcional
        end note

        note right of ready_queue_ts
          **✓ Implementado**
          • ReadyQueue - cola FIFO simple
          • Métodos: enqueue, dequeue, isEmpty, clear, toArray
          • Manejo de PIDs en orden de llegada
        end note

        note right of fcfs_ts
          **✓ Implementado**
          • SchedulerFCFS - First Come First Served
          • Extiende BaseScheduler
          • Política no expropiativa (FIFO puro)
          • Integrado con motor sandbox
        end note

        note right of rr_ts
          **✓ Implementado**
          • SchedulerRR - Round Robin con quantum
          • onDesalojoActual() - re-encolado al final
          • getQuantum() - reinicio en cada L→C
        end note

        note right of spn_ts
          **✓ Implementado** <<nuevo>>
          • SchedulerSPN (no expropiativo)
          • Selección por ráfaga próxima más corta
          • Orden estable con seq para empates
          • compareForPreemption() → false (nunca expropia)
        end note

        note right of srtn_ts
          **✓ Implementado** <<nuevo>>
          • SchedulerSRTN (expropiativo)
          • Selección por menor restante (dinámico)
          • Expropia en N→L/B→L si nuevo < actual
          • getRemaining() y getNow() para tiempo dinámico
          • compareForPreemption() → lógica de expropiación
        end note

        note right of priority_ts
          **✓ Implementado** <<nuevo>>
          • SchedulerPriority con aging lazy
          • Preemption con compareForPreemption()
          • Guards y telemetría integrada
          • Convención: menor número = mayor prioridad
          • Aging: pEff = pBase - floor((t-tReady)/ageQuantum)*ageStep
        end note
      }

      package "io" as IO {
        rectangle "parser.ts" as parser_ts
        rectangle "export.ts" as export_ts
        
        parser_ts -[hidden]down-> export_ts

        note right of parser_ts
          **✓ Implementado**
          • Parser de tandas JSON (procesos_tanda_*.json)
          • Mapeo: nombre→pid, tiempo_arribo→arribo, etc.
          • Validación de entrada y conversión a Proceso
          • extractBloqueoESGlobal() para costos
          • parseTandaJSON() - función principal
        end note

        note right of export_ts
          **✓ Implementado**
          • Exportación de resultados a JSON/CSV
          • exportToJSON() - simulación completa
          • exportMetricsToCSV() - métricas por proceso
          • exportTraceToCSV() - eventos y slices
          • Helpers de descarga para browser
        end note
      }

      package "metrics" as METRICS {
        rectangle "metricas.ts" as metricas_ts
        note right of metricas_ts
          **✓ Implementado** <<nuevo>>
          • MetricsBuilder con build() y buildGlobal()
          • ProcessMetrics: TRp, TE, TRn por proceso
          • GlobalMetrics: promedios, throughput, contadores
          • Tiempo simulación desde trace (eventos/slices)
          • Contadores refinados: cambios contexto, expropiaciones
        end note
      }

      package "gantt" as GANTT {
        rectangle "schema.ts" as schema_ts
        rectangle "builder.ts" as builder_ts
        
        schema_ts -[hidden]down-> builder_ts

        note right of schema_ts
          **✓ Implementado** <<nuevo>>
          • GanttSeg - segmento individual de ejecución
          • GanttTrack - track por proceso (pid, segments)
          • GanttModel - modelo completo con tMin/tMax
          • Tipos para renderizado de diagramas Gantt
        end note

        note right of builder_ts
          **✓ Implementado** <<nuevo>>
          • GanttBuilder.build() - conversión trace→gantt
          • Solo slices CPU (filtra TIP/TCP/TFP/IO)
          • Tracks agrupados por pid
          • Cálculo correcto tMin/tMax para rango temporal
        end note
      }
    

    package "stores" as STORES {
      rectangle "simulacion.ts" as simulacion_store_ts
      rectangle "costosFactory.ts" as costos_factory_ts  
      rectangle "schedulerFactory.ts" as scheduler_factory_ts
      
      simulacion_store_ts -[hidden]down-> costos_factory_ts
      costos_factory_ts -[hidden]down-> scheduler_factory_ts
      
      note right of simulacion_store_ts
        **✓ Implementado** <<integración Paso 9>>
        • Svelte stores: simulationConfig, procesos, simulationResult
        • Funciones puras: runSimulation(), runSimulationFromTanda()
        • Acciones: loadFromTanda(), executeSimulation()
        • Derived stores: hasProcesses, canExecute, metricas, gantt
        • Estado completo de la aplicación centralizado
      end note
      
      note right of costos_factory_ts
        **✓ Implementado** <<movido desde application>>
        • costosFromUI() - factory con defaults y validaciones
        • Centraliza normalización de costos desde UI
        • Protege de valores negativos/undefined
      end note
      
      note right of scheduler_factory_ts
        **✓ Implementado** <<movido desde application>>
        • getRunner() - selecciona engine según política
        • Soporte: FCFS, RR, SPN, SRTN, PRIORITY
        • Validaciones específicas (quantum>0, prioridades)
        • Encapsula lógica de selección de algoritmo
      end note
    }

  package "routes" as ROUTES {
    rectangle "+layout.svelte" as layout_svelte
    rectangle "+page.svelte" as main_page

    package "simulacion" as R_SIM {
      rectangle "+page.svelte" as simulacion_page
    }
    
    package "resultados" as R_RES {
      rectangle "+page.svelte" as resultados_page
    }
    
    layout_svelte -[hidden]down-> main_page
    main_page -[hidden]down-> R_SIM
    R_SIM -[hidden]down-> R_RES

    note right of layout_svelte
      **⏳ Pendiente UI**
      • Layout general, estilos, navigation shell
    end note

    note right of main_page
      **⏳ Pendiente UI**
      • Página principal del simulador
      • Landing page y navegación
    end note

    note right of simulacion_page
      **⏳ Pendiente UI**
      • Pantalla para cargar tanda y ejecutar simulación
      • Consume simulacion.ts stores
      • UI de selección de política y parámetros
      • Vista de métricas y Gantt usando export.ts
    end note

    note right of resultados_page
      **⏳ Pendiente UI**
      • Visualización de resultados finales
      • Usa export.ts para descargas JSON/CSV
      • Renderiza gantt y métricas desde stores
    end note
  }

  rectangle "app.d.ts" as app_dts
  note right of app_dts
    **⏳ Pendiente**
    • Tipos globales para SvelteKit/ambient
    • Extensiones de App namespace (si las hay)
  end note
}

MODEL -[hidden]down-> ENGINE
ENGINE -[hidden]down-> SCHED
SCHED -[hidden]down-> IO
IO -[hidden]down-> METRICS
METRICS -[hidden]down-> GANTT
GANTT -[hidden]down-> STORES
STORES -[hidden]down-> ROUTES

' Motor y tipos
    engine_ts --> engine_types_ts : usa tipos
    engine_ts --> queue_ts : utiliza cola
    engine_ts --> fcfs_ts : usa SchedulerFCFS
    engine_ts --> proceso_ts : lee modelo
    engine_ts --> costos_ts : aplica costos
    engine_ts --> telemetry_ts : guards runtime
    telemetry_ts --> invariants_ts : checks condicionales

' Planificadores y cola
scheduler_ts --> ready_queue_ts : usa ReadyQueue
fcfs_ts --> scheduler_ts : extiende BaseScheduler
fcfs_ts --> ready_queue_ts : hereda uso
rr_ts --> ready_queue_ts
    spn_ts --> ready_queue_ts
    spn_ts --> telemetry_ts : guards anti-errores
    srtn_ts --> ready_queue_ts
    srtn_ts --> telemetry_ts : guards anti-errores
priority_ts --> ready_queue_ts



' Gantt y esquemas
builder_ts --> schema_ts

' Stores y factories
simulacion_store_ts --> costos_factory_ts : usa costosFromUI
simulacion_store_ts --> scheduler_factory_ts : usa getRunner
costos_factory_ts --> costos_ts : usa makeCostos
scheduler_factory_ts --> engine_ts : usa runRR, runSPN, etc.

' IO y modelo
parser_ts --> proceso_ts : convierte a Proceso
export_ts --> engine_types_ts : exporta Trace
export_ts --> metricas_ts : exporta métricas
export_ts --> schema_ts : exporta GanttModel

' UI y stores
simulacion_page --> simulacion_store_ts : consume stores
resultados_page --> export_ts : usa helpers descarga

' ----------------------------------------------------------
legend bottom
**Convenciones del Diagrama**
• Cada rectángulo = archivo físico
• Las notas indican "qué contiene" y estado actual
• Las flechas muestran dependencias principales (informativas)

**Convención del Proyecto**: menor número ⇒ mayor prioridad
• Priority Scheduling: p=1 > p=2 > p=3... (1 es máxima prioridad)
• Event Ordering: 1:C→T > 2:C→B > 3:C→L > 4:B→L > 5:N→L > 6:L→C

**Estados de implementación:**
• **✓ Implementado** - Código completo y testeado (Golden Cases validados)
• **⏳ Pendiente** - Archivos creados, pendiente implementación

**Cambios (Pasos 8-9 - Completos):**
**Paso 8 - Priority + Aging, Métricas, Gantt:**
• scheduler/priority.ts: Priority + aging lazy, guards, preemption
• metrics/metricas.ts: TRp, TE, TRn, throughput, contadores eventos  
• gantt/builder.ts + schema.ts: Solo CPU slices, tracks por pid, tMin/tMax
• engine.ts: runPriority() con event loop completo + preemption

**Paso 9 - Fachada y Reorganización:**
• io/parser.ts: Importador tandas JSON (antes ui/services/importers/)
• io/export.ts: Exportación JSON/CSV para resultados
• stores/simulacion.ts: Store principal + funciones puras (fusión application/)
• stores/costosFactory.ts + schedulerFactory.ts: Factories integrados
• Eliminadas: application/, ui/ (reorganización según README.md original)

**Convenciones del Core:**
• Priority: p=0 > p=1 > p=2... (0 es máxima prioridad)  
• Aging: pEff = pBase - floor((t - tReady) / ageQuantum) * ageStep
• Event Order: 1:C→T > 2:C→B > 3:C→L > 4:B→L > 5:N→L > 6:L→C
• Telemetría: Expropiaciones solo C→L con reason='preempt'

rectangle "ORDEN_EVENTOS.md" as orden_eventos_md

note right of orden_eventos_md
  **✓ Implementado** <<nuevo>>
  • Documentación de event ordering
  • Prioridades de eventos (1:C→T, 2:C→B, etc.)
  • Anti-patterns y pitfalls
  • Guía de prevención de bugs
end note

invariants_ts --> orden_eventos_md : "implementa reglas"

**Anti-errores clave (SPN/SRTN):**
❌ **No recalcular** fin ráfaga con min(r,q) - usar r.restante directo
❌ **No medir restante(actual)** sin descontar ejecutado: rest - (t - sliceStart)
❌ **No despachar desde C→T** - administrativo, CPU se libera en fin real
❌ **No mantener procesos terminados** en cola ready - filtrar restante <= 0
❌ **No encolar con restante <= 0** - guard en push() con warning/assert
 **TCP** desplaza inicio slice (tStart = t + TCP), no cuenta en ráfaga/quantum
 **Empates**: C→T/C→B (prio 1/2) gana a C→L (prio 3); C→L queda stale
 **Orden estable**: usar seq para desempatar en SPN/SRTN con misma clave
 **SRTN filtrado**: next() elimina procesos con restante <= 0 antes de elegir
 **Purga en origen**: onFinish() remueve PID terminado de cola ready
 **Expropiación estricta**: SRTN usa < (no <=) para evitar thrashing

**Colores por Módulo:**
• **model** - Tipos y entidades base
• **engine** - Motor de simulación  
• **scheduler** - Algoritmos de planificación
• **io** - Entrada/salida de datos
• **metrics** - Cálculo de métricas
• **gantt** - Generación de diagramas
• **stores** - Estado de aplicación
• **routes** - Páginas de la aplicación
endlegend

@enduml
