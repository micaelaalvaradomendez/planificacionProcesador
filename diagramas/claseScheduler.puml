@startuml 07-clases-sched-minheap
title Schedulers por "shortest" – Estructuras y claves

skinparam classAttributeIconSize 0

interface IScheduler {
  + onAdmit(pid: number): void
  + onReady(pid: number): void
  + onBlock(pid: number): void
  + onFinish(pid: number): void
  + onDesalojoActual(pid: number): void
  + next(): number | undefined
}

class BaseScheduler {
  - rq: IReadyStructure
  + onAdmit(pid): void
  + onReady(pid): void
  + onBlock(pid): void
  + onFinish(pid): void
  + onDesalojoActual(pid): void
  {abstract} + next(): number | undefined
}

interface IReadyStructure {
  + insert(pid: number, key: number, seq: number): void
  + extractMin(): number | undefined
  + updateKey(pid: number, newKey: number): void
  + isEmpty(): boolean
}

class ReadyQueueMin <<min-heap>> {
  - heap: (pid, key, seq)[]
  - index: Map<pid, idx>
  + insert(pid, key, seq)
  + extractMin(): number | undefined
  + updateKey(pid, newKey)
  + isEmpty(): boolean
}

class SchedulerSPN {
  - key(p): number  ' ráfaga PRÓXIMA
  - seqCounter: number
  + next(): number | undefined
}

class SchedulerSRTN {
  - key(p): number  ' restante ACTUAL
  - seqCounter: number
  + onAdmit(pid): void
  + onReady(pid): void
  + onDesalojoActual(pid): void
  + updateOnTick(pid, restante): void  ' opcional si actualizás clave en tiempo real
  + next(): number | undefined
}

IScheduler <|.. BaseScheduler
BaseScheduler <|-- SchedulerSPN
BaseScheduler <|-- SchedulerSRTN
IReadyStructure <|.. ReadyQueueMin
BaseScheduler o-- IReadyStructure : usa

note right of ReadyQueueMin
  comparador: (key asc, seq asc)
  key = ráfaga próxima (SPN) o restante (SRTN)
  seq = orden estable de inserción
end note

note bottom
  Integración con el motor:
   • SPN: en cada L→C, tomar el pid con menor ráfaga próxima.
     Arribos más cortos NO expropian.
   • SRTN: al N→L / B→L de un pid con menor RESTANTE,
     forzar C→L del actual y L→C del nuevo (TCP).
   • Prioridades de eventos:
     C→T(1) > C→B(2) > C→L(3) > B→L(4) > N→L(5) > L→C(6).
end note
@enduml
