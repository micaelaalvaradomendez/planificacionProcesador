@startuml 06-secuencia-rr
title Round Robin – Timer, desalojo y re-encolado (TCP en despacho)

actor "Motor" as ENG
participant "EventQueue\n(t, prioridad, _seq)" as EQ
participant "SchedulerRR" as SCH
participant "Timer" as TM
participant "CPU" as CPU
participant "Proceso(pid)" as P

== Llega listo y se despacha ==
ENG -> EQ : push( L→C @ t_d, pid )
EQ  -> ENG : pop() = L→C @ t_d
ENG -> CPU : reservar CPU (TCP)
ENG -> CPU : abrir slice en t_s = t_d + TCP
note right of CPU
  t_s = t_d + TCP
  Programar:
    • C→B/C→T @ t_s + rRestante  (fin natural de ráfaga)
    • C→L      @ t_s + q         (timer RR)
  El quantum se REINICIA en cada L→C.
  Empate en mismo t: C→T/C→B (prio 1/2) > C→L (prio 3).
end note

== Programación de fin de rebanada ==
ENG -> EQ : push( C→B @ (t_s + r), pid )  ' fin de ráfaga (si r era la última -> C→T)
ENG -> TM : programar expiración(q) @ (t_s + q)
ENG -> EQ : push( C→L @ (t_s + q), pid )  ' desalojo por timer

== Empate: vence quantum vs fin ráfaga ==
group Empate en mismo t
  note over EQ
    Prioridades:
    C→T (1) > C→B (2) > C→L (3)
    Si (t_s+q) == (t_s+r): gana FIN de ráfaga.
  end note
end

== Caso A: vence fin de ráfaga (t_s+r <= t_s+q) ==
EQ  -> ENG : pop() = C→B @ (t_s+r)  /  o C→T si era última
ENG -> CPU : cerrar slice [t_s, t_s+r]\nliberar CPU
ENG -> SCH : onBlock(pid) / onFinish(pid)
ENG -> EQ  : push( B→L @ (t_s+r + bloqueoES), pid )\n' si última ráfaga → no B→L
ENG -> ENG : despacharSiLibre(t_s+r)\n(guard por tick)
... continúa flujo normal ...

== Caso B: vence timer (t_s+q < t_s+r) ==
EQ  -> ENG : pop() = C→L @ (t_s+q)
ENG -> CPU : cerrar slice [t_s, t_s+q]\nliberar CPU
ENG -> SCH : onDesalojoActual(pid)\nre-encolar pid (READY)
ENG -> ENG : despacharSiLibre(t_s+q)\n' puede caer L→C para otro pid o el mismo
note right
  Reglas RR:
  • El trabajo ejecutado fue runFor = q.
  • r := r - q (se actualiza ráfaga restante).
  • El quantum se consume sólo en CPU (no costos).
end note

== Nuevo despacho (TCP aplica nuevamente) ==
EQ  -> ENG : pop() = L→C @ t'_d
ENG -> CPU : abrir nuevo slice en t'_s = t'_d + TCP
... se repite la lógica RR ...

legend right
  Claves RR:
  • Timer provoca C→L (desalojo) y re-encolado.
  • Si final de ráfaga y expiración coinciden, prima fin de ráfaga:
      C→T(1)/C→B(2) > C→L(3).
  • B→L no consume CPU; TCP sólo desplaza el inicio del nuevo slice.
  • TIP/TCP/TFP NO son CPU.
endlegend
@enduml
