@startuml Estructura - Mapa de Archivos

!define MODEL_COLOR #E8F4FD
!define ENGINE_COLOR #FDF2E9
!define SCHED_COLOR #E8F8F5
!define IO_COLOR #F3E5F5
!define METRICS_COLOR #EBF5FB
!define GANTT_COLOR #FADBD8
!define STORES_COLOR #FDEAA7
!define ROUTES_COLOR #D5E8D4
!define TEST_COLOR #FFF2CC

skinparam shadowing false
skinparam defaultTextAlignment left
skinparam packageStyle rectangle
skinparam ArrowColor #666666
skinparam PackageBorderColor #999999
skinparam RectangleBorderColor #BBBBBB
skinparam NoteBackgroundColor #FFFEF5
skinparam NoteBorderColor #E6D8A8
skinparam minClassWidth 180
skinparam maxMessageSize 150
skinparam nodesep 20
skinparam ranksep 30
hide circle

title Proyecto Simulador de Planificación – Mapa de Archivos

package "src" as SRC {

  package "lib" as LIB {

      package "model" as MODEL {
        rectangle "proceso.ts" as proceso_ts
        rectangle "rafaga.ts" as rafaga_ts
        rectangle "estados.ts" as estados_ts
        rectangle "costos.ts" as costos_ts
        
        proceso_ts -[hidden]down-> rafaga_ts
        rafaga_ts -[hidden]down-> estados_ts
        estados_ts -[hidden]down-> costos_ts

        note right of proceso_ts
          **✓ Implementado**
          • Tipos de Proceso (pid, arribo, ráfagas)
          • Estado del proceso (N, L, C, B, F)
          • servicioTotal() - suma de ráfagas CPU
          • isProcesoValido() - validación básica
        end note

        note right of rafaga_ts
          **✓ Implementado**
          • Utilidades para manejar rafagas
          • Índice/actual y chequeos de restantes
          • rafagaActual() - obtiene ráfaga por índice
          • quedanRafagas() - verifica ráfagas restantes
        end note

        note right of estados_ts
          **✓ Implementado**
          • Definición de estados
          • Reglas de transición válidas (invariantes)
          • Estados canónicos (N,L,C,B,F)
          • isTransicionLegal() - validador de transiciones
          • assertTransicionLegal() - error si ilegal
          • transicionarEstado() - transición inmutable
        end note

        note right of costos_ts
          **✓ Implementado**
          • Interface Costos (TIP, TCP, TFP, bloqueoES)
          • COSTOS_DEF - defaults (bloqueoES=25)
          • validarCostos() - verifica valores ≥ 0
          • makeCostos() - constructor saneado
        end note
      }

      package "engine" as ENGINE {
        rectangle "types.ts" as engine_types_ts
        rectangle "queue.ts" as queue_ts
        rectangle "invariants.ts" as invariants_ts
        rectangle "telemetry.ts" as telemetry_ts
        rectangle "engine.ts" as engine_ts
        
        engine_types_ts -[hidden]down-> queue_ts
        queue_ts -[hidden]down-> invariants_ts
        invariants_ts -[hidden]down-> telemetry_ts
        telemetry_ts -[hidden]down-> engine_ts

        note right of engine_types_ts
          **✓ Implementado**
          • Tipos del motor (EventType, SimEvent)
          • Estructura de traza (slices, eventos)
          • Contratos de entrada/salida de run()
        end note

        note right of queue_ts
          **✓ Implementado**
          • Cola de eventos
          • Orden por timestamp + prioridad de evento
        end note

        note right of invariants_ts
          **✓ Implementado** <<nuevo>>
          • Invariantes críticos del motor
          • assertSingleCPU() - un solo proceso en CPU
          • assertNoNegativeRestante() - restante >= 0
          • assertValidEnqueue() - no encolar restante <= 0
          • logSliceEvent() - debug estructurado de slices
        end note

        note right of telemetry_ts
          **✓ Implementado** <<nuevo>>
          • Wrapper condicional para telemetría
          • TELEMETRY_CONFIG - habilitar en desarrollo
          • TelemetryGuards - invariants condicionales
          • Configuración por NODE_ENV y DEBUG_SLICES
        end note

        note right of engine_ts
          **✓ Implementado** <<mod - Paso 7>>
          • runFCFSSandbox() - motor FCFS completo
          • runRR() - motor Round Robin con quantum
          • runSPN() - motor SPN (no expropiativo) <<nuevo>>
          • runSRTN() - motor SRTN con expropiación <<nuevo>>
          • getNextBurst() / getRemainingNow() helpers
          • tryPreemptIfNeeded() - hook expropiación SRTN
          • Guard anti-doble-dispatch por tick
          • Estado runtime por proceso (idxRafaga, restante)
          • Costos TIP/TCP/TFP integrados
          • Bloqueos E/S: B→L @ t+bloqueoES
          • Validación C→T stale por expectedSliceStart
          • NOW timer para SRTN
        end note
      }

      package "scheduler" as SCHED {
        rectangle "scheduler.ts" as scheduler_ts
        rectangle "ready-queue.ts" as ready_queue_ts
        rectangle "fcfs.ts" as fcfs_ts
        rectangle "rr.ts" as rr_ts
        rectangle "spn.ts" as spn_ts
        rectangle "srtn.ts" as srtn_ts
        rectangle "priority.ts" as priority_ts
        
        scheduler_ts -[hidden]down-> ready_queue_ts
        ready_queue_ts -[hidden]down-> fcfs_ts
        fcfs_ts -[hidden]down-> rr_ts
        rr_ts -[hidden]down-> spn_ts
        spn_ts -[hidden]down-> srtn_ts
        srtn_ts -[hidden]down-> priority_ts

        note right of scheduler_ts
          **✓ Implementado** <<mod>>
          • IScheduler - interfaz completa de planificadores
          • BaseScheduler - clase base abstracta
          • Métodos: onAdmit, onReady, onBlock, onFinish, next()
          • onDesalojoActual?() - re-encolado opcional
          • compareForPreemption?() - hook expropiación opcional
        end note

        note right of ready_queue_ts
          **✓ Implementado**
          • ReadyQueue - cola FIFO simple
          • Métodos: enqueue, dequeue, isEmpty, clear, toArray
          • Manejo de PIDs en orden de llegada
        end note

        note right of fcfs_ts
          **✓ Implementado**
          • SchedulerFCFS - First Come First Served
          • Extiende BaseScheduler
          • Política no expropiativa (FIFO puro)
          • Integrado con motor sandbox
        end note

        note right of rr_ts
          **✓ Implementado**
          • SchedulerRR - Round Robin con quantum
          • onDesalojoActual() - re-encolado al final
          • getQuantum() - reinicio en cada L→C
        end note

        note right of spn_ts
          **✓ Implementado** <<nuevo>>
          • SchedulerSPN (no expropiativo)
          • Selección por ráfaga próxima más corta
          • Orden estable con seq para empates
          • compareForPreemption() → false (nunca expropia)
        end note

        note right of srtn_ts
          **✓ Implementado** <<nuevo>>
          • SchedulerSRTN (expropiativo)
          • Selección por menor restante (dinámico)
          • Expropia en N→L/B→L si nuevo < actual
          • getRemaining() y getNow() para tiempo dinámico
          • compareForPreemption() → lógica de expropiación
        end note

        note right of priority_ts
          **⏳ Pendiente**
          • Planificador por prioridades
          • (Opcional) Envejecimiento/ajuste de prioridad
        end note
      }

      package "io" as IO {
        rectangle "parser.ts" as parser_ts
        rectangle "export.ts" as export_ts
        
        parser_ts -[hidden]down-> export_ts

        note right of parser_ts
          **⏳ Pendiente**
          • Validación y normalización de entrada (JSON/CSV)
          • Conversión a estructuras de Proceso
        end note

        note right of export_ts
          **⏳ Pendiente**
          • Exportación de trazas/métricas (JSON/CSV)
          • Helpers para descarga/serialización
        end note
      }

      package "metrics" as METRICS {
        rectangle "metricas.ts" as metricas_ts
        note right of metricas_ts
          **⏳ Pendiente**
          • Cálculo de métricas por proceso y globales
          • TRp, TE, TRn, promedios y agregados
        end note
      }

      package "gantt" as GANTT {
        rectangle "schema.ts" as schema_ts
        rectangle "builder.ts" as builder_ts
        
        schema_ts -[hidden]down-> builder_ts

        note right of schema_ts
          **⏳ Pendiente**
          • Tipos para el modelo de Gantt de UI
          • Items, inicio/fin y normalizaciones
        end note

        note right of builder_ts
          **⏳ Pendiente**
          • Conversión de trace.slices a modelo de Gantt
          • Agrupación y orden cronológico para pintar
        end note
      }
    

    package "stores" as STORES {
      rectangle "simulacion.ts" as simulacion_store_ts
      note right of simulacion_store_ts
        **⏳ Pendiente**
        • Svelte stores para política seleccionada
        • Resultados (trace/fin) y costos en UI
      end note
    }

  package "routes" as ROUTES {
    rectangle "+layout.svelte" as layout_svelte
    rectangle "+page.svelte" as main_page

    package "simulacion" as R_SIM {
      rectangle "+page.svelte" as simulacion_page
    }
    
    package "resultados" as R_RES {
      rectangle "+page.svelte" as resultados_page
    }
    
    layout_svelte -[hidden]down-> main_page
    main_page -[hidden]down-> R_SIM
    R_SIM -[hidden]down-> R_RES

    note right of layout_svelte
      **⏳ Pendiente**
      • Layout general, estilos, navigation shell
    end note

    note right of main_page
      **⏳ Pendiente**
      • Página principal del simulador
      • Landing page y navegación
    end note

    note right of simulacion_page
      **⏳ Pendiente**
      • Pantalla para cargar tanda y ejecutar simulación
      • UI de selección de política y parámetros
      • Vista de métricas y Gantt básicos
    end note

    note right of resultados_page
      **⏳ Pendiente**
      • Visualización de resultados finales
      • Botones de exportación (JSON/CSV)
    end note
  }

  rectangle "app.d.ts" as app_dts
  note right of app_dts
    **⏳ Pendiente**
    • Tipos globales para SvelteKit/ambient
    • Extensiones de App namespace (si las hay)
  end note
}

MODEL -[hidden]down-> ENGINE
ENGINE -[hidden]down-> SCHED
SCHED -[hidden]down-> IO
IO -[hidden]down-> METRICS
METRICS -[hidden]down-> GANTT
GANTT -[hidden]down-> STORES
STORES -[hidden]down-> ROUTES

' Motor y tipos
    engine_ts --> engine_types_ts : usa tipos
    engine_ts --> queue_ts : utiliza cola
    engine_ts --> fcfs_ts : usa SchedulerFCFS
    engine_ts --> proceso_ts : lee modelo
    engine_ts --> costos_ts : aplica costos
    engine_ts --> telemetry_ts : guards runtime
    telemetry_ts --> invariants_ts : checks condicionales

' Planificadores y cola
scheduler_ts --> ready_queue_ts : usa ReadyQueue
fcfs_ts --> scheduler_ts : extiende BaseScheduler
fcfs_ts --> ready_queue_ts : hereda uso
rr_ts --> ready_queue_ts
    spn_ts --> ready_queue_ts
    spn_ts --> telemetry_ts : guards anti-errores
    srtn_ts --> ready_queue_ts
    srtn_ts --> telemetry_ts : guards anti-errores
priority_ts --> ready_queue_ts



' Gantt y esquemas
builder_ts --> schema_ts

' UI y lógica
simulacion_page --> simulacion_store_ts
simulacion_page --> engine_ts
simulacion_page --> builder_ts
simulacion_page --> metricas_ts
resultados_page --> export_ts

' Parser y modelo
parser_ts --> proceso_ts

' ----------------------------------------------------------
legend bottom
**Convenciones del Diagrama**
• Cada rectángulo = archivo físico
• Las notas indican "qué contiene" y estado actual
• Las flechas muestran dependencias principales (informativas)

**Estados de implementación:**
• **✓ Implementado** - Código completo y testeado (Golden Cases validados)
• **⏳ Pendiente** - Archivos creados, pendiente implementación

**Cambios (Paso 7 - A prueba de balas):**
• scheduler/spn.ts <<nuevo>>: SPN no expropiativo, selección por ráfaga próxima
• scheduler/srtn.ts <<nuevo>>: SRTN expropiativo, restante dinámico + expropiación  
• scheduler/scheduler.ts <<mod>>: añadido compareForPreemption() opcional
• engine.ts <<mod>>: runSPN()/runSRTN(), helpers getNextBurst/getRemainingNow
                     tryPreemptIfNeeded() hook en N→L/B→L para SRTN
                     NOW timer para schedulers dinámicos
• engine/invariants.ts <<nuevo>>: Guards y asserts para desarrollo
• engine/telemetry.ts <<nuevo>>: Wrapper condicional para telemetría
• ORDEN_EVENTOS.md <<nuevo>>: Contratos de ordenamiento y anti-patrones

rectangle "ORDEN_EVENTOS.md" as orden_eventos_md

note right of orden_eventos_md
  **✓ Implementado** <<nuevo>>
  • Documentación de event ordering
  • Prioridades de eventos (1:C→T, 2:C→B, etc.)
  • Anti-patterns y pitfalls
  • Guía de prevención de bugs
end note

invariants_ts --> orden_eventos_md : "implementa reglas"

**Anti-errores clave (SPN/SRTN):**
❌ **No recalcular** fin ráfaga con min(r,q) - usar r.restante directo
❌ **No medir restante(actual)** sin descontar ejecutado: rest - (t - sliceStart)
❌ **No despachar desde C→T** - administrativo, CPU se libera en fin real
❌ **No mantener procesos terminados** en cola ready - filtrar restante <= 0
❌ **No encolar con restante <= 0** - guard en push() con warning/assert
✅ **TCP** desplaza inicio slice (tStart = t + TCP), no cuenta en ráfaga/quantum
✅ **Empates**: C→T/C→B (prio 1/2) gana a C→L (prio 3); C→L queda stale
✅ **Orden estable**: usar seq para desempatar en SPN/SRTN con misma clave
✅ **SRTN filtrado**: next() elimina procesos con restante <= 0 antes de elegir
✅ **Purga en origen**: onFinish() remueve PID terminado de cola ready
✅ **Expropiación estricta**: SRTN usa < (no <=) para evitar thrashing

**Colores por Módulo:**
• **model** - Tipos y entidades base
• **engine** - Motor de simulación  
• **scheduler** - Algoritmos de planificación
• **io** - Entrada/salida de datos
• **metrics** - Cálculo de métricas
• **gantt** - Generación de diagramas
• **stores** - Estado de aplicación
• **routes** - Páginas de la aplicación
endlegend

@enduml
