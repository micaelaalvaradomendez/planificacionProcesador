@startuml 06-actividad-rr
title RR – Reglas de corte del slice por quantumRestante == 0

start
:pop() -> e=(t, tipo, pid);

if (tipo == "L→C") then (sí)
  :t_s = t + TCP;  ' inicio real del slice (TCP no es CPU)
  :quantumRestante = q;
  :rafagaRestante = r_actual;
  :runFor = min(rafagaRestante, quantumRestante);
  :programar C→B @ (t_s + rafagaRestante);\n(si última ráfaga → C→T en t_s + r + TFP)
  :programar C→L @ (t_s + quantumRestante);\n' desalojo por timer
elseif (tipo == "C→B") then (sí)
  :cerrar slice [t_s, t];
  :liberar CPU;\nSCH.onBlock(pid);
  :push( B→L @ t + bloqueoES, pid );
  :despacharSiLibre(t);\n' guard por tick
elseif (tipo == "C→T") then (sí)
  :cerrar slice si correspondía en tFinCPU;\nSCH.onFinish(pid);
  note right : C→T es administrativo; no despachar aquí
elseif (tipo == "C→L") then (sí)
  :Si cpu.pid ≠ pid → ignorar (stale);
  :runFor = t - t_s;
  :rafagaRestante -= runFor;
  :onDesalojoActual(pid) → READY.enqueue(pid);
  :despacharSiLibre(t);
elseif (tipo == "B→L") then (sí)
  :avanzar a próxima ráfaga;\nREADY.enqueue(pid);
  :despacharSiLibre(t);
else (otro)
  :ignorar/loggear;
endif

stop

legend right
  Decisión de corte:
   • Corte por FIN de ráfaga: evento C→B (o C→T si última).
   • Corte por QUANTUM: evento C→L.
   • Empate (mismo t): GANA fin de ráfaga (C→T/C→B tiene mayor prioridad que C→L).
  Notas:
   • TCP desplaza t_s; quantum y ráfaga corren desde t_s.
   • TIP/TCP/TFP no son CPU.
   • B→L no consume CPU; el costo real es bloqueoES.
endlegend
@enduml
