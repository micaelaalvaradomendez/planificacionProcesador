@startuml 06-actividad-rr
title RR – Reglas de corte del slice por quantumRestante == 0

start
:pop() -> e=(t, tipo, pid);

if (tipo == "L→C") then (sí)
  :t_s = t + TCP;  ' inicio real del slice (TCP no es CPU)
  :quantumRestante = q;
  :rafagaRestante = r_actual;
  :runFor = min(rafagaRestante, quantumRestante);
  :programar C→B @ (t_s + rafagaRestante);\n(si última ráfaga → C→T en t_s + r + TFP)
  :programar C→L @ (t_s + quantumRestante);\n' desalojo por timer
elseif (tipo == "C→B") then (sí)
  :cerrar slice [t_s, t];
  :liberar CPU;\nSCH.onBlock(pid);
  :push( B→L @ t + bloqueoES, pid );
  :despacharSiLibre(t);\n' guard por tick
elseif (tipo == "C→T") then (sí)
  :cerrar slice si correspondía en tFinCPU;\nSCH.onFinish(pid);
  note right : C→T es administrativo; no despachar aquí
elseif (tipo == "C→L") then (sí)
  :cerrar slice [t_s, t];\nliberar CPU;
  :rafagaRestante := rafagaRestante - runFor;
  if (rafagaRestante > 0) then (sí)
    :SCH.onDesalojoActual(pid);\nREADY.enqueue(pid);
  else (no)
    :(raro) si justo llegó a 0\ndebería haberse tratado como fin de ráfaga;
  endif
  :despacharSiLibre(t);\n' puede o no reingresar el mismo pid
elseif (tipo == "B→L") then (sí)
  :avanzar a próxima ráfaga;\nREADY.enqueue(pid);
  :despacharSiLibre(t);
else (otro)
  :ignorar/loggear;
endif

stop

legend right
  Decisión de corte:
   • Corte por FIN de ráfaga: evento C→B (o C→T si última).
   • Corte por QUANTUM: evento C→L.
   • Empate (mismo t): GANA fin de ráfaga (C→T/C→B tiene mayor prioridad que C→L).
  Notas:
   • TCP desplaza t_s; quantum y ráfaga corren desde t_s.
   • TIP/TCP/TFP no son CPU.
   • B→L no consume CPU; el costo real es bloqueoES.
endlegend
@enduml
